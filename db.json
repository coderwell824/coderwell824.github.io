{"meta":{"version":1,"warehouse":"4.0.1"},"models":{"Asset":[{"_id":"themes/quiet/source/css/index.less","path":"css/index.less","modified":0,"renderable":1},{"_id":"themes/quiet/source/image/favicon.ico","path":"image/favicon.ico","modified":0,"renderable":1},{"_id":"themes/quiet/source/image/logo.png","path":"image/logo.png","modified":0,"renderable":1},{"_id":"themes/quiet/source/image/pattern.png","path":"image/pattern.png","modified":0,"renderable":1},{"_id":"themes/quiet/source/js/fancybox-images.js","path":"js/fancybox-images.js","modified":0,"renderable":1},{"_id":"themes/quiet/source/js/gitalk.min.js","path":"js/gitalk.min.js","modified":0,"renderable":1},{"_id":"themes/quiet/source/js/fancybox.umd.js","path":"js/fancybox.umd.js","modified":0,"renderable":1},{"_id":"themes/quiet/source/js/gotop.js","path":"js/gotop.js","modified":0,"renderable":1},{"_id":"themes/quiet/source/js/hljs.min.js","path":"js/hljs.min.js","modified":0,"renderable":1},{"_id":"themes/quiet/source/js/index.js","path":"js/index.js","modified":0,"renderable":1},{"_id":"themes/quiet/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/quiet/source/css/highlight/atom-one-dark.less","path":"css/highlight/atom-one-dark.less","modified":0,"renderable":1},{"_id":"themes/quiet/source/css/pages/about.less","path":"css/pages/about.less","modified":0,"renderable":1},{"_id":"themes/quiet/source/css/pages/archive.less","path":"css/pages/archive.less","modified":0,"renderable":1},{"_id":"themes/quiet/source/css/pages/categories.less","path":"css/pages/categories.less","modified":0,"renderable":1},{"_id":"themes/quiet/source/css/pages/home.less","path":"css/pages/home.less","modified":0,"renderable":1},{"_id":"themes/quiet/source/css/pages/links.less","path":"css/pages/links.less","modified":0,"renderable":1},{"_id":"themes/quiet/source/css/pages/post.less","path":"css/pages/post.less","modified":0,"renderable":1},{"_id":"themes/quiet/source/css/pages/tag.less","path":"css/pages/tag.less","modified":0,"renderable":1},{"_id":"themes/quiet/source/css/pages/tags.less","path":"css/pages/tags.less","modified":0,"renderable":1},{"_id":"themes/quiet/source/css/plugin/fancybox.css","path":"css/plugin/fancybox.css","modified":0,"renderable":1},{"_id":"themes/quiet/source/css/plugin/gitalk.css","path":"css/plugin/gitalk.css","modified":0,"renderable":1},{"_id":"themes/quiet/source/css/public/article_cente.less","path":"css/public/article_cente.less","modified":0,"renderable":1},{"_id":"themes/quiet/source/css/public/color.less","path":"css/public/color.less","modified":0,"renderable":1},{"_id":"themes/quiet/source/css/public/content.less","path":"css/public/content.less","modified":0,"renderable":1},{"_id":"themes/quiet/source/css/public/header_background.less","path":"css/public/header_background.less","modified":0,"renderable":1},{"_id":"themes/quiet/source/css/public/mixins.less","path":"css/public/mixins.less","modified":0,"renderable":1},{"_id":"themes/quiet/source/css/widget/food.less","path":"css/widget/food.less","modified":0,"renderable":1},{"_id":"themes/quiet/source/css/widget/grouping.less","path":"css/widget/grouping.less","modified":0,"renderable":1},{"_id":"themes/quiet/source/css/widget/header.less","path":"css/widget/header.less","modified":0,"renderable":1},{"_id":"themes/quiet/source/css/widget/header_body.less","path":"css/widget/header_body.less","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"dc68227eb84521e4b27b77bba36b44b75c17ef87","modified":1659235373693},{"_id":"source/about/index.md","hash":"113b99995a2e6059f386d5133d154e99a84031fc","modified":1659230510938},{"_id":"source/categories/index.md","hash":"95dfc14c5423a6b914e0b420b35660198d984d7d","modified":1659230510939},{"_id":"source/links/index.md","hash":"a294ef605267efbad9a130a203fdc0b8b3815a6a","modified":1659230510939},{"_id":"source/tags/index.md","hash":"5151016ddb5ecb41e4e00ded9cd837256bf885d3","modified":1659230510939},{"_id":"themes/quiet/.gitignore","hash":"b0e13971511bbc4a0203f783a25687f545ca4fa5","modified":1659230510939},{"_id":"themes/quiet/LICENSE","hash":"b141d557809fd4804d6d828dfcaa5c4adb734bc7","modified":1659230510940},{"_id":"themes/quiet/README-EN.md","hash":"39d926029f37133ee20d81c026d9279533954fff","modified":1659230510940},{"_id":"themes/quiet/README.md","hash":"5ce46f628ffbfc458746db4f5a5c02625be3b8e1","modified":1659230510940},{"_id":"themes/quiet/_config.yml","hash":"4a82525b5472308bc3118f1cbd757cb37bcc3708","modified":1675654255677},{"_id":"themes/quiet/package.json","hash":"b1ab898b6dc5b7ae5d40b13db729d50ff9a93bb2","modified":1659234088410},{"_id":"themes/quiet/layout/404.ejs","hash":"ee787012f3d6c350473e1e6fd33f4c13a9f8fc5a","modified":1659230510940},{"_id":"themes/quiet/layout/about.ejs","hash":"3089eb0e0c753ec1b0d8d064224b02b78d8f993f","modified":1659230510943},{"_id":"themes/quiet/layout/archive.ejs","hash":"e3451030d7bcc5468ead22d01164ed7072664d87","modified":1659230510943},{"_id":"themes/quiet/layout/categories.ejs","hash":"c6d5a0a9b79cc56087327f9d3286b9d7514e1af9","modified":1659230510943},{"_id":"themes/quiet/layout/index.ejs","hash":"2d1245d2b8d231e1306c4704a450977299e7318d","modified":1659230510943},{"_id":"themes/quiet/layout/layout.ejs","hash":"8195cc46c79d02fff13b42a8b7541b2ef0f8abf7","modified":1675652871275},{"_id":"themes/quiet/layout/links.ejs","hash":"a2782c2816c33dc2e0365866374ccf1c5f8ae57f","modified":1659230510943},{"_id":"themes/quiet/layout/post.ejs","hash":"d934b6a6e1f8b42ec5b5e80c1beee62e42bce81a","modified":1659230510944},{"_id":"themes/quiet/layout/tag.ejs","hash":"9df2d4ab6334cb386a58eac7f65fb3e251a86250","modified":1659230510944},{"_id":"themes/quiet/layout/tags.ejs","hash":"a0c7e74f4de2a8201d8ef0fa1cb2d8c317846bb0","modified":1659230510944},{"_id":"themes/quiet/layout/_partial/foot.ejs","hash":"d06c0e0ad5bd68b9a5c7bedb84a6dc8d5b03db65","modified":1659230510941},{"_id":"themes/quiet/layout/_partial/head.ejs","hash":"ba9bd3282bc195efde3093008f0f915c2b12d5e0","modified":1659230510941},{"_id":"themes/quiet/layout/_partial/header.ejs","hash":"2d0eb265df6def742cbcab6aca72ee98733bd8a0","modified":1659230510941},{"_id":"themes/quiet/layout/_partial/home.ejs","hash":"ce98d15abd111c9d6b76d47ec4d9f2f2ae28c6d8","modified":1659230510941},{"_id":"themes/quiet/layout/_partial/post_centent.ejs","hash":"c3cd12198ba8d86b2427c79b42f89ed73a127c6b","modified":1659230510941},{"_id":"themes/quiet/layout/_partial/post_head.ejs","hash":"324217741ac1a67cb7c853f4034eedc5b856a6c9","modified":1659230510941},{"_id":"themes/quiet/layout/_partial/post_paging.ejs","hash":"673965e84b2d23d4cca6bd822752b272260205e7","modified":1659230510942},{"_id":"themes/quiet/layout/_widget/analytics.ejs","hash":"e6f5fea8a5e1642a569cfeaba24f74e68efd9e09","modified":1659230510942},{"_id":"themes/quiet/layout/_widget/comment.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1675570243388},{"_id":"themes/quiet/layout/_widget/gotop.ejs","hash":"a894ee61bc45c29594ce59f72809fea5f2c55ae0","modified":1659230510942},{"_id":"themes/quiet/layout/_widget/grouping.ejs","hash":"370b5483e6092289ecba933f3a622936e39133d5","modified":1659230510942},{"_id":"themes/quiet/layout/_widget/header_body.ejs","hash":"e1498276e2c3962d8dc9f114ec51e97a8f2874d7","modified":1659230510942},{"_id":"themes/quiet/layout/_widget/sidebar.ejs","hash":"1382c2c52645973b9558ea28de77bdd146276053","modified":1675652807041},{"_id":"themes/quiet/source/css/index.less","hash":"5d9c79ae6a842fa2f74f74e7d6931cc509b75346","modified":1659230510945},{"_id":"themes/quiet/source/image/logo.png","hash":"3487c0299f2f69abc8bbbd5d7c61ad77b311c801","modified":1659230510948},{"_id":"themes/quiet/source/image/pattern.png","hash":"e9a79b9b5716c781e8f5acf3462e42fae7f39741","modified":1659230510948},{"_id":"themes/quiet/source/js/fancybox-images.js","hash":"1eee6b143f944bce1dab2a9f2141435e545bc537","modified":1659230510949},{"_id":"themes/quiet/source/js/gotop.js","hash":"78f04d8833cf9916f71469fb80722004dce09b28","modified":1659230510953},{"_id":"themes/quiet/source/js/index.js","hash":"2023e077272d3bfbc8c02791b402b6cf5ce6b118","modified":1659230510954},{"_id":"themes/quiet/source/css/highlight/atom-one-dark.less","hash":"da8603ef348b38d6ef090fa9172a6521e53b6c89","modified":1659230510944},{"_id":"themes/quiet/source/css/pages/about.less","hash":"9b026d5307839bda6d81710a191033e5222994c4","modified":1659230510945},{"_id":"themes/quiet/source/css/pages/archive.less","hash":"7394878db4bc9746c1433c98e0b3769e612971d8","modified":1659230510945},{"_id":"themes/quiet/source/css/pages/categories.less","hash":"cb5aa9b353a44fda0d7e500763b88d906feae238","modified":1659230510945},{"_id":"themes/quiet/source/css/pages/home.less","hash":"16f7dd1eb047fac29f7a06532e48d2164bee2294","modified":1659230510945},{"_id":"themes/quiet/source/css/pages/links.less","hash":"abcc3aca4d6503db9276e33b005aa27ff02f29e5","modified":1659230510945},{"_id":"themes/quiet/source/css/pages/post.less","hash":"3a0afce471d5f5dbc5d5d0c8b7997e44a560944e","modified":1659230510946},{"_id":"themes/quiet/source/css/pages/tag.less","hash":"755ade4fec877912d071bebd783f90a01eede0fd","modified":1659230510946},{"_id":"themes/quiet/source/css/pages/tags.less","hash":"0f7ddd0ca583c543892734dae5e3613e495e9908","modified":1659230510946},{"_id":"themes/quiet/source/css/plugin/fancybox.css","hash":"cbce0cfc36f47e30e9c9824875f0b854a05f1916","modified":1659230510946},{"_id":"themes/quiet/source/css/plugin/gitalk.css","hash":"5663e9951ff23989672afe0a559abf1d8a114e8f","modified":1659230510946},{"_id":"themes/quiet/source/css/public/article_cente.less","hash":"b8e023cbebd15873157ffc5560e9f03714dc4d5d","modified":1659230510947},{"_id":"themes/quiet/source/css/public/color.less","hash":"eb152b594ddc29873d58bf1aa3d0d9898c33c726","modified":1659230510947},{"_id":"themes/quiet/source/css/public/content.less","hash":"7a9528cba1883537ba990b7680bb3fcdac7363cc","modified":1659230510947},{"_id":"themes/quiet/source/css/public/header_background.less","hash":"bb4e6c1bbacf0e4b714f4a0d534560cc51b45db1","modified":1659230510947},{"_id":"themes/quiet/source/css/public/mixins.less","hash":"a3b4c2f504a454bda7ebb705831763c4b0968cf9","modified":1659230510947},{"_id":"themes/quiet/source/css/widget/food.less","hash":"5374f82f9fd1bd6b4beef06c2443a16cc378e126","modified":1659230510947},{"_id":"themes/quiet/source/css/widget/grouping.less","hash":"50129c57e5367c483e62868d2aea460ab32c18cd","modified":1659230510948},{"_id":"themes/quiet/source/css/widget/header.less","hash":"dda759916684b58f9ecc8bb903cfcb3463164f3c","modified":1659230510948},{"_id":"themes/quiet/source/image/favicon.ico","hash":"fad2c16f133094e29f9c4aa8a946b7aa200ec98b","modified":1659230510948},{"_id":"themes/quiet/source/css/widget/header_body.less","hash":"30f31f96cafc2b7ae933c3f72c6f444ee904934f","modified":1659230510948},{"_id":"themes/quiet/source/js/fancybox.umd.js","hash":"d6203bf95728c98e8d12fdc8100f98da48260312","modified":1659230510949},{"_id":"themes/quiet/source/js/hljs.min.js","hash":"f599d9b58453de85ab2ee2e68b2702a3d55c0830","modified":1659230510954},{"_id":"themes/quiet/source/js/jquery.min.js","hash":"ad886e472b3557f3dc7dfa2bc43468ab8d1cef5b","modified":1659230510955},{"_id":"themes/quiet/source/js/gitalk.min.js","hash":"8f0a3d5a46e23eeab52c965387a3ffcd7e00d723","modified":1659230510953},{"_id":"public/about/index.html","hash":"aff3dfa55ab59b2466eba15659fb6781f4a62ab2","modified":1675654563327},{"_id":"public/categories/index.html","hash":"01e9a1051cbc9ca35929e758d3df68723ea20a3b","modified":1675995993785},{"_id":"public/links/index.html","hash":"4825eb6d233ed183a43d9f7e63dff0af10f1cc59","modified":1675654563327},{"_id":"public/tags/index.html","hash":"c4dde9aa8553de3896fb302c7c20ed8b5beb97bf","modified":1675654563327},{"_id":"public/2022/07/31/hello-world/index.html","hash":"84790a18ac3423f5cb455b0c01a9f45ad384a23f","modified":1659230788425},{"_id":"public/archives/index.html","hash":"e1d7c91e07f2e587015d903a910e51232f4043cb","modified":1675995816290},{"_id":"public/archives/2022/index.html","hash":"821132b9f79a84c602d85383830e10d5b808b55f","modified":1659236154352},{"_id":"public/archives/2022/07/index.html","hash":"821132b9f79a84c602d85383830e10d5b808b55f","modified":1659236154352},{"_id":"public/index.html","hash":"5600af8a34620587856a479d9ffe44c37e7e7a99","modified":1675995816290},{"_id":"public/image/favicon.ico","hash":"fad2c16f133094e29f9c4aa8a946b7aa200ec98b","modified":1659230788425},{"_id":"public/image/logo.png","hash":"3487c0299f2f69abc8bbbd5d7c61ad77b311c801","modified":1659230788425},{"_id":"public/image/pattern.png","hash":"e9a79b9b5716c781e8f5acf3462e42fae7f39741","modified":1659230788425},{"_id":"public/js/fancybox-images.js","hash":"1eee6b143f944bce1dab2a9f2141435e545bc537","modified":1659230788425},{"_id":"public/js/gotop.js","hash":"78f04d8833cf9916f71469fb80722004dce09b28","modified":1659230788425},{"_id":"public/js/index.js","hash":"2023e077272d3bfbc8c02791b402b6cf5ce6b118","modified":1659230788425},{"_id":"public/css/plugin/fancybox.css","hash":"cbce0cfc36f47e30e9c9824875f0b854a05f1916","modified":1659230788425},{"_id":"public/css/highlight/atom-one-dark.css","hash":"babf73b3a1b7b94627602a2e467830c9435d6665","modified":1659230788425},{"_id":"public/css/pages/about.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1659230788425},{"_id":"public/css/pages/categories.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1659230788425},{"_id":"public/css/pages/links.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1659230788425},{"_id":"public/css/pages/post.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1659230788425},{"_id":"public/css/pages/home.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1659230788425},{"_id":"public/css/pages/tag.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1659230788425},{"_id":"public/css/pages/tags.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1659230788425},{"_id":"public/css/public/article_cente.css","hash":"0394d82e8ecb91e5f188c0e60669f8ad8228fa4a","modified":1659230788425},{"_id":"public/css/public/color.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1659230788425},{"_id":"public/css/public/content.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1659230788425},{"_id":"public/css/pages/archive.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1659230788425},{"_id":"public/css/public/header_background.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1659230788425},{"_id":"public/css/public/mixins.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1659230788425},{"_id":"public/css/widget/food.css","hash":"001fd1cee16fcc9821c2eb7a97385c3717f6cd93","modified":1659230788425},{"_id":"public/css/widget/grouping.css","hash":"bd9a14c36a397bff9e87cf0bb9c5a0563e5637bd","modified":1659230788425},{"_id":"public/css/widget/header.css","hash":"8d5d0f56a9aa4b94adabe0283b27a0d1ec9ac16c","modified":1659230788425},{"_id":"public/css/widget/header_body.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1659230788425},{"_id":"public/css/plugin/gitalk.css","hash":"5663e9951ff23989672afe0a559abf1d8a114e8f","modified":1659230788425},{"_id":"public/css/index.css","hash":"641fdecdf3d7731dcfdc2f47c11cf503531fd09f","modified":1659230788425},{"_id":"public/js/jquery.min.js","hash":"ad886e472b3557f3dc7dfa2bc43468ab8d1cef5b","modified":1659230788425},{"_id":"public/js/fancybox.umd.js","hash":"d6203bf95728c98e8d12fdc8100f98da48260312","modified":1659230788425},{"_id":"public/js/hljs.min.js","hash":"f599d9b58453de85ab2ee2e68b2702a3d55c0830","modified":1659230788425},{"_id":"public/js/gitalk.min.js","hash":"8f0a3d5a46e23eeab52c965387a3ffcd7e00d723","modified":1659230788425},{"_id":"public/2022/07/17/hello-world/index.html","hash":"d665bb907c51b16204642904dbf0f9aef478f79b","modified":1659236154352},{"_id":"source/_posts/GC.md","hash":"42226889605b6a5d12840dad2cfc575cb0659092","modified":1675565835719},{"_id":"source/_posts/垃圾回收机制.md","hash":"f96bbe8f6440e0bd7f40cd690adfce1786dd1620","modified":1675654237974},{"_id":"source/.DS_Store","hash":"b48c4f7d61a5928be717d4bd654481ff1eab36ee","modified":1675566188631},{"_id":"public/archives/2023/index.html","hash":"e1d7c91e07f2e587015d903a910e51232f4043cb","modified":1675995816290},{"_id":"public/archives/2023/02/index.html","hash":"e1d7c91e07f2e587015d903a910e51232f4043cb","modified":1675995816290},{"_id":"public/2023/02/03/垃圾回收机制/index.html","hash":"5a4fa82570996921ff48612f4436510d3d887b9f","modified":1675995780541},{"_id":"source/_posts/.DS_Store","hash":"870b430aa4aca877fafa4aff1528d00efe2c9ec5","modified":1675654121882},{"_id":"source/_posts/image/.DS_Store","hash":"79a9221ac45eec6392e5e5ddd7d913560679054f","modified":1675654128611},{"_id":"source/_posts/image/iShot2023-02-06 11.28.00.png","hash":"8afc8ee2f2df26689346158e386be7cf7a5ddc00","modified":1675654080334},{"_id":"public/categories/Javascript/index.html","hash":"86fc014e9e0a7fed550181af4244451048593af1","modified":1675654563327},{"_id":"source/_posts/diff算法.md","hash":"ba414d39cc6671ef1de7c3d749e08009ed3fa036","modified":1675995662340},{"_id":"public/2023/02/06/diff算法/index.html","hash":"ea9619dc4da7c753a96c3c89a1164ebb73fd99d1","modified":1675995816290},{"_id":"public/categories/React/index.html","hash":"ca1b084862df6a9fe6ddd57668d13e53bc7f851d","modified":1675685801408},{"_id":"source/_posts/React源码解析1:jsxDev.md","hash":"ae3b02f44aceafd377866fabaf66bad26c923f9e","modified":1675995643842},{"_id":"public/2023/02/10/React源码解析1:jsxDev/index.html","hash":"c9a99521b0ff4bb7acc1232e79571d2ae7c65c71","modified":1675995780541},{"_id":"public/categories/React原理/index.html","hash":"2dd921b6b89eb2b346bb8d774d3db742fa38ad44","modified":1675995780541},{"_id":"public/categories/React源码/index.html","hash":"d00f7bf3ea7c7775211e5f3708348e5b1eb9544a","modified":1675995816290},{"_id":"source/_posts/jsxDev.md","hash":"ae3b02f44aceafd377866fabaf66bad26c923f9e","modified":1675995643842},{"_id":"public/2023/02/10/jsxDev/index.html","hash":"c9a99521b0ff4bb7acc1232e79571d2ae7c65c71","modified":1675995816290}],"Category":[{"name":"Javascript","_id":"clds8g0hr0000xws62t297bma"},{"name":"React","_id":"cldss27sz000150s68kx1g6zw"},{"name":"React原理","_id":"cldxvtmer0000sos6ecszbeaa"},{"name":"React源码","_id":"cldxwm58v000173s6fc7u1e3h"}],"Data":[],"Page":[{"title":"个人简介","date":"2020-11-02T16:00:00.000Z","aubot":"Cange-Q","portrait":"https://cdn.jsdelivr.net/gh/duogongneng/MyBlogImg/imgIMG_7327.jpeg","describe":"一个阳光快乐的BOY,在正合适的年龄里希望遇见正好的你。","type":"about","layout":"about","comments":0,"_content":"","source":"about/index.md","raw":"---\ntitle: 个人简介\ndate: 2020-11-03\naubot: Cange-Q\nportrait: 'https://cdn.jsdelivr.net/gh/duogongneng/MyBlogImg/imgIMG_7327.jpeg'\ndescribe: '一个阳光快乐的BOY,在正合适的年龄里希望遇见正好的你。'\ntype: \"about\"\nlayout: \"about\"\ncomments: false\n---","updated":"2022-07-31T01:21:50.938Z","path":"about/index.html","_id":"cl68n2nx00000pde0hojhgg98","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"文章分类","date":"2020-11-01T16:00:00.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 文章分类\ndate: 2020-11-02\ntype: categories\nlayout: categories\n---","updated":"2022-07-31T01:21:50.939Z","path":"categories/index.html","comments":1,"_id":"cl68n2nx50002pde0d8wgaqg5","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"友情链接","date":"2020-09-18T16:00:00.000Z","type":"links","layout":"links","comments":0,"_content":"","source":"links/index.md","raw":"---\ntitle: 友情链接\ndate: 2020-09-19\ntype: \"links\"\nlayout: \"links\"\ncomments: false\n---","updated":"2022-07-31T01:21:50.939Z","path":"links/index.html","_id":"cl68n2nx60003pde0fu0cb1de","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2020-09-19T08:19:22.000Z","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2020-09-19 16:19:22\nlayout: \"tags\"\n---","updated":"2022-07-31T01:21:50.939Z","path":"tags/index.html","comments":1,"_id":"cl68n2nx70004pde0cssy1ua7","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"V8中的JavaScript垃圾回收机制","cover":"https://www.python51.com/wp-content/uploads/2022/12/20221216-70.png","_content":"\n# 浏览器垃圾的产生\n\n首先，我们要先明白在js中内存垃圾的定义是什么，在js内存管理策略中它会对失去**可达性**(无引用或者无法通过某种方式进行访问)的空间进行回收。既失去可达性的内存空间会被视为是垃圾\n在正常开发中，我们不可避免的会在程序中进行各种变量声明函数创建等操作，这些操作无疑都是需要从浏览器处进行内存申请，浏览器进行内存分配，但是如果我们在使用引用类型变量时更改了其引用地址，就导致之前被引用的堆地址失去可达性而被白白占用(参考下面代码例子)，如果变量变多这种被白白占用的地址会越来越多，导致新的变量能分配使用的内存会越来越小，系统运行速度会越来越慢，达到临界值时会导致系统崩溃\n\n```javascript\n let test = {\n    a: 1,\n    b: 2\n\n  }\n  // 上方引用地址无变量引用导致白白占用内存空间\n  test = [1, 2, 3, 4, 6]\n```\n\n# 垃圾回收机制\n\n由上文我们可以知道浏览器在运行程序时就会产生垃圾，但是正常情况我们开发时也从未主动去回收垃圾，那程序为何依旧能正常运作呢。那是因为JavaScript自己内部会定时(实时太消耗性能)通过GC(Garbage Collection)进行垃圾回收\n\n## 垃圾回收策略\n\n而在GC中常用的回收策略\n\n### 标记清除(Mark-Sweep)\n\n标记清除是JavaScript引擎中进行垃圾回收中使用到最多的算法，在目前主流的浏览器厂商中几乎都是可以看到标记清除算法，只不过不同浏览器厂商优化不同，而且不同的浏览器上运行的性能也有差异\n 而此算法主要核心分为两部分标记和清除\n 在代码执行阶段，为程序中所有的变量添加上一个二进制字符(二进制运算最快)并初始值置为0(默认全是垃圾)，然后遍历所有的对象，被使用的变量标记置为1，在程序运行结束时回收掉所有标记为零的变量，回收结束之后将现存变量标记统一置为0，等待下一轮回收开启\n\n#### 优点\n\n标记清除算法思路清晰，实现比较简单\n\n#### 缺点\n\n由于系统分配的内存时间不同，回收的先后顺序也是不同的，这时就会导致剩余空闲空间并不是连续的，出现了内存碎片现象\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45958c664c3c4f37ab84db61840756b8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n内存碎片化之后，新的分配空间被分配时需要先计算一下满足符合要求的空间，增加了计算负担。同时如果后续系统需要分配的新变量使用空间很大，虽然系统总剩余内存是满足需求，但是并没有连续的满足需求的空间进行分配，这时可能会出现分配失败\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d7cb0228d2d4a399682271391c2d4af~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n所以虽然标记清除算法比较简单但是缺点也是很明显由于内存碎片的诞生导致的分配时间较长和空间浪费，所以只要解决掉内存碎片这个致命问题，这两个问题就会迎刃而解\n 这时候 **标记整理** (Mark-Compact)算法闪亮登场，他的清除逻辑和标记清除算法基本相似不过进行了优化，会在清除结束之后讲活着的空间进行整理向一端移动，同时清理掉内存的边界\n\n### 引用计数\n\n引用计数算法顾名思义，他的策略就是跟踪记录每个变量值被使用的次数，如果一个引用类型的值给一个声明的变量赋值，则将这个引用类型的值的引用次数为1，如果同一个值被又被赋值给另一个变量，则引用计数再加1，如果之前被赋值的变量值变更成了其他引用类型，则原本的引用类型引用计数减1，如果这个引用类型的引用计数为0时表示，此时为不可达状态，浏览器垃圾回收器就将此类型占用的空间进行回收掉(此处是实时的，当计数变为0既会被立即回收)\n\n#### 优点\n\n1、实时回收，引用计数当归零就立即进行回收操作。 2、不会暂停执行栈，标记清除算法定时进行垃圾回收时会先暂停程序运行，来进行垃圾回收，而引用计数是实时回收不会暂停程序的运行\n\n#### 缺点\n\n1、空间浪费，由于需要进行计数，所以需要开辟空间来存储计数器，同时由于引用无上限故占用空间也是无上限。 2、无法解决循环引用无法回收(致命问题)，循环引用既两个引用类型AB，A有一个地址指向了B,B也有一个对象指向了A,导致两者引用计数为2，正常情况下当test函数运行结束进行垃圾回收，但是AB两者的基数都不是0则回收失败，无法清除，这种情况大量发生时会造成大量的内存空间被浪费，故引用计数算法现在已经很少使用逐渐被标记清除算法替代\n\n```css\n  function test() {\n    let A = new Object()\n    let B = new Object()\n    B.a = A\n    A.b = B\n  }\n```\n\n# V8对GC的优化\n\n## 分代式优化\n\n之前GC的清除算法无论是标记清除还是标记整理，在进行回收时都需要检查内存中的所有对象，但是如果存在一些，体积大，存活时间长，创建早的内存来进行检查，相当于是做了无用功，而新创建，体积小和存活时间短的对象需要更加频繁的检查所以基于这个问题V8提出了新生代和老生代的优化策略。将内存空间划分为新生代和老生代两个部分，不同部分执行不同的回收策略。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79967c264db445d2a0b7474d5785ee13~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n### 新生代\n\n顾名思义新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 1～8M 的容量。 而新生代中的内存又会被拆分为两部分，使用区和空闲区，浏览器进行内存申请时分配使用区空间，当使用区空间快被写满时则进行一次垃圾回收，新生代的垃圾回收器会对使用区的活动对象进行标记，标记完成之后将使用区活跃的对象复制到空闲区，并进行排序，随后进入垃圾清理阶段，对使用区进行清理，清理操作完成之后，使用区和空闲区进行角色互换，之前的空闲区变成新的使用区，之前的使用区变成新的空闲区，循环往复。\n\n当一个对象被多次复制还未被清理掉，故此对象会被认定为生命周期较长的对象，会被从新生代移动到老生代中，采用老生代的垃圾回收机制管理。\n\n不过还需要注意一个特殊情况，如果新生代的复制一个对象到空闲区，如果空闲区的使用空间超过25%之后这个对象会被立即复制到老生代，而25%的红线要求是为了保证进行空闲区和使用区翻转时对于新的对象分配空间操作不会被影响。\n\n### 老生代\n\n相比于新生代，老生代顾名思义存放的就是一些生命周期比较长，经过多次新生代垃圾回收还存在的对象，同样的相比于新生代不仅垃圾回收频率较低，存储空间也是比新生代大的多。而老生代的回收算法就比较简单就是标记清除算法，不过在v8中为了处理标记清除算法产生的内存碎片问题，使用了标记整理算法进行空间优化大大提高了回收效率。\n\n## 并行回收\n\n众所周知JavaScript是一门单线程语言，所以在进行GC回收时会阻塞js脚本的运行导致系统停顿，等GC回收结束后恢复运行，这被称为全停顿。\n\n但是这样的话会存在极大的风险，如果GC回收时间较长，就会导致系统停顿时间较长这是不可被接受的。所以V8引擎加入了并行回收的优化机制，在开启GC回收线程之后，会同时开启多个辅助线程进行处理，提高回处理时间，虽然增加了一部分线程之间协调的时间，但是总时间比一个线程用时来讲大大的缩短。避免系统卡顿时间过长。\n\n## 增量标记\n\n由于全停顿标记策略在处理老生代垃圾回收时即使是有并行处理优化但是消耗时间也会消耗大量的时间，所以在2011年时V8团队又提出了增量标记策略来进行优化。\n 增量标记思想就是将一次GC标记过程进行拆分，一次执行一小部分，执行完毕后继续执行脚本，执行一段脚本之后又继续执行刚刚拆分的GC标记任务，循环往复直至这次GC标记完成。\n\n### 三色标记法(恢复与暂停)\n\n在引入三色标记法之前的GC标记只是将活动的变量标记为黑色，不活动的变量标记为白色，当GC标记过程结束之后，系统会回收掉所有的白色标记变量，但是这种非黑即白的方法虽然清除起来非常方便但是存在一个问题执行一段时间之后无法知道执行到了哪里，不能进行暂停。所以V8又引入了一个灰色进行暂停和恢复操作。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41fda88ed208434d800a1f258be59f4d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n如图所示，在GC标记开始时所有对象都是白色的，然后从根对象开始进行标记，先将这组对象标记为灰色然后进行记录，如果此时进行中断，后续恢复时既从灰色标记时开始即可，当回收器从标记工作表中弹出对象并访问他们的引用对象时，会将灰色置为黑色，同时将下一个引用对象置为灰色，继续往下进行标记工作。直至无可标记为灰色对象为止，此时表示GC标记过程结束，将所有未标记的变量进行回收工作。所以三色标记法可以渐进执行而不用每次执行都要全盘进行扫描整个内存空间，可以配合增量回收减少全停顿时间，提升体验\n\n### 写屏障\n\n在一次完成GC标记暂停中，如果执行任务程序时内存中存在的变量引用关系被改变了，这样会导致此次GC存在问题。所以V8团队提出了写屏障作为保护。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36a75580ea724bdabffce8fbcedd0c17~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n如图所示，现有A、B、C三个对象依次被引用，且在GC过程中已经被标记了，但是在暂停GC任务，插入执行程序任务之后，引用关系被改变了，新增了一个新变量D，但是此时程序中也未存在灰色标记的变量，下一步进行清除机制时，新变量D按清除机制来讲是要被清除掉，但是这是极其不合理的，一个新的变量还存在引用就被回收掉，这会导致程序云行报错。此时写屏障机制就派上用场了，一旦有黑色的对象引用白色的对象，就会强制将被引用的白色变量标记为灰色，保证下一次的增量GC正确运行，这个机制称为强三色不变性(白色变量D被黑色变量B引用之后会被强制置灰保证程序运行正确性)。\n\n### 惰性清理\n\n在增量GC标记之后下一步就是来真正回收内存空间，通过惰性清理来进行清除释放内存。惰性清理机制运行原理是在进行回收时如果内存足够就可以将这个回收清理时间稍微延迟一下，让JavaScript脚本先执行，清理时也不会一下全部清理掉所有的垃圾，会根据按需进行清理直至所有垃圾都回收完毕，然后继续等待下个GC标记阶段执行结束。\n\n### 并发回收\n\n虽然增量标记和惰性清理的出现使主线程停顿时间大大减少了，但是总体的停顿时间其实并未减少，如果真正细算起来甚至还增加了，应用程序的吞吐量也被降低，不过用户和浏览器的交互体验大大提升牺牲也是值得的。但是后续V8团队为了使回收更加高效， 又使用了并发回收机制，他是在主线程在执行程序任务时，主动开启辅助线程进行GC回收。而主线程又可以自由执行而不会挂起(标记操作全部由辅助进程操作)。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dab8f88e33e94c038f73b57e268c58b5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n# 总结\n\n综合上文的知识点V8引擎的垃圾回收机制也逐渐揭开:分代式策略是V8里面垃圾回收机制的中流砥柱， 只不过老生代的垃圾回收略显麻烦为了优化性能和体验开发团队煞费苦心，在GC标记阶段通过并发回收策略开启辅助线程完成标记操作，清理操作时通过增量任务和惰性回收策略进行清理(同时也会开启辅助线程进行清理)大大提升了回收效率提高了人机交互的体验感。不得不说当下web式应用程序能够飞速发展少不了V8引擎的一份力\n\n","source":"_posts/垃圾回收机制.md","raw":"---\ntitle: V8中的JavaScript垃圾回收机制\ncategory: Javascript\ncover: https://www.python51.com/wp-content/uploads/2022/12/20221216-70.png\n---\n\n# 浏览器垃圾的产生\n\n首先，我们要先明白在js中内存垃圾的定义是什么，在js内存管理策略中它会对失去**可达性**(无引用或者无法通过某种方式进行访问)的空间进行回收。既失去可达性的内存空间会被视为是垃圾\n在正常开发中，我们不可避免的会在程序中进行各种变量声明函数创建等操作，这些操作无疑都是需要从浏览器处进行内存申请，浏览器进行内存分配，但是如果我们在使用引用类型变量时更改了其引用地址，就导致之前被引用的堆地址失去可达性而被白白占用(参考下面代码例子)，如果变量变多这种被白白占用的地址会越来越多，导致新的变量能分配使用的内存会越来越小，系统运行速度会越来越慢，达到临界值时会导致系统崩溃\n\n```javascript\n let test = {\n    a: 1,\n    b: 2\n\n  }\n  // 上方引用地址无变量引用导致白白占用内存空间\n  test = [1, 2, 3, 4, 6]\n```\n\n# 垃圾回收机制\n\n由上文我们可以知道浏览器在运行程序时就会产生垃圾，但是正常情况我们开发时也从未主动去回收垃圾，那程序为何依旧能正常运作呢。那是因为JavaScript自己内部会定时(实时太消耗性能)通过GC(Garbage Collection)进行垃圾回收\n\n## 垃圾回收策略\n\n而在GC中常用的回收策略\n\n### 标记清除(Mark-Sweep)\n\n标记清除是JavaScript引擎中进行垃圾回收中使用到最多的算法，在目前主流的浏览器厂商中几乎都是可以看到标记清除算法，只不过不同浏览器厂商优化不同，而且不同的浏览器上运行的性能也有差异\n 而此算法主要核心分为两部分标记和清除\n 在代码执行阶段，为程序中所有的变量添加上一个二进制字符(二进制运算最快)并初始值置为0(默认全是垃圾)，然后遍历所有的对象，被使用的变量标记置为1，在程序运行结束时回收掉所有标记为零的变量，回收结束之后将现存变量标记统一置为0，等待下一轮回收开启\n\n#### 优点\n\n标记清除算法思路清晰，实现比较简单\n\n#### 缺点\n\n由于系统分配的内存时间不同，回收的先后顺序也是不同的，这时就会导致剩余空闲空间并不是连续的，出现了内存碎片现象\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45958c664c3c4f37ab84db61840756b8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n内存碎片化之后，新的分配空间被分配时需要先计算一下满足符合要求的空间，增加了计算负担。同时如果后续系统需要分配的新变量使用空间很大，虽然系统总剩余内存是满足需求，但是并没有连续的满足需求的空间进行分配，这时可能会出现分配失败\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d7cb0228d2d4a399682271391c2d4af~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n所以虽然标记清除算法比较简单但是缺点也是很明显由于内存碎片的诞生导致的分配时间较长和空间浪费，所以只要解决掉内存碎片这个致命问题，这两个问题就会迎刃而解\n 这时候 **标记整理** (Mark-Compact)算法闪亮登场，他的清除逻辑和标记清除算法基本相似不过进行了优化，会在清除结束之后讲活着的空间进行整理向一端移动，同时清理掉内存的边界\n\n### 引用计数\n\n引用计数算法顾名思义，他的策略就是跟踪记录每个变量值被使用的次数，如果一个引用类型的值给一个声明的变量赋值，则将这个引用类型的值的引用次数为1，如果同一个值被又被赋值给另一个变量，则引用计数再加1，如果之前被赋值的变量值变更成了其他引用类型，则原本的引用类型引用计数减1，如果这个引用类型的引用计数为0时表示，此时为不可达状态，浏览器垃圾回收器就将此类型占用的空间进行回收掉(此处是实时的，当计数变为0既会被立即回收)\n\n#### 优点\n\n1、实时回收，引用计数当归零就立即进行回收操作。 2、不会暂停执行栈，标记清除算法定时进行垃圾回收时会先暂停程序运行，来进行垃圾回收，而引用计数是实时回收不会暂停程序的运行\n\n#### 缺点\n\n1、空间浪费，由于需要进行计数，所以需要开辟空间来存储计数器，同时由于引用无上限故占用空间也是无上限。 2、无法解决循环引用无法回收(致命问题)，循环引用既两个引用类型AB，A有一个地址指向了B,B也有一个对象指向了A,导致两者引用计数为2，正常情况下当test函数运行结束进行垃圾回收，但是AB两者的基数都不是0则回收失败，无法清除，这种情况大量发生时会造成大量的内存空间被浪费，故引用计数算法现在已经很少使用逐渐被标记清除算法替代\n\n```css\n  function test() {\n    let A = new Object()\n    let B = new Object()\n    B.a = A\n    A.b = B\n  }\n```\n\n# V8对GC的优化\n\n## 分代式优化\n\n之前GC的清除算法无论是标记清除还是标记整理，在进行回收时都需要检查内存中的所有对象，但是如果存在一些，体积大，存活时间长，创建早的内存来进行检查，相当于是做了无用功，而新创建，体积小和存活时间短的对象需要更加频繁的检查所以基于这个问题V8提出了新生代和老生代的优化策略。将内存空间划分为新生代和老生代两个部分，不同部分执行不同的回收策略。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79967c264db445d2a0b7474d5785ee13~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n### 新生代\n\n顾名思义新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 1～8M 的容量。 而新生代中的内存又会被拆分为两部分，使用区和空闲区，浏览器进行内存申请时分配使用区空间，当使用区空间快被写满时则进行一次垃圾回收，新生代的垃圾回收器会对使用区的活动对象进行标记，标记完成之后将使用区活跃的对象复制到空闲区，并进行排序，随后进入垃圾清理阶段，对使用区进行清理，清理操作完成之后，使用区和空闲区进行角色互换，之前的空闲区变成新的使用区，之前的使用区变成新的空闲区，循环往复。\n\n当一个对象被多次复制还未被清理掉，故此对象会被认定为生命周期较长的对象，会被从新生代移动到老生代中，采用老生代的垃圾回收机制管理。\n\n不过还需要注意一个特殊情况，如果新生代的复制一个对象到空闲区，如果空闲区的使用空间超过25%之后这个对象会被立即复制到老生代，而25%的红线要求是为了保证进行空闲区和使用区翻转时对于新的对象分配空间操作不会被影响。\n\n### 老生代\n\n相比于新生代，老生代顾名思义存放的就是一些生命周期比较长，经过多次新生代垃圾回收还存在的对象，同样的相比于新生代不仅垃圾回收频率较低，存储空间也是比新生代大的多。而老生代的回收算法就比较简单就是标记清除算法，不过在v8中为了处理标记清除算法产生的内存碎片问题，使用了标记整理算法进行空间优化大大提高了回收效率。\n\n## 并行回收\n\n众所周知JavaScript是一门单线程语言，所以在进行GC回收时会阻塞js脚本的运行导致系统停顿，等GC回收结束后恢复运行，这被称为全停顿。\n\n但是这样的话会存在极大的风险，如果GC回收时间较长，就会导致系统停顿时间较长这是不可被接受的。所以V8引擎加入了并行回收的优化机制，在开启GC回收线程之后，会同时开启多个辅助线程进行处理，提高回处理时间，虽然增加了一部分线程之间协调的时间，但是总时间比一个线程用时来讲大大的缩短。避免系统卡顿时间过长。\n\n## 增量标记\n\n由于全停顿标记策略在处理老生代垃圾回收时即使是有并行处理优化但是消耗时间也会消耗大量的时间，所以在2011年时V8团队又提出了增量标记策略来进行优化。\n 增量标记思想就是将一次GC标记过程进行拆分，一次执行一小部分，执行完毕后继续执行脚本，执行一段脚本之后又继续执行刚刚拆分的GC标记任务，循环往复直至这次GC标记完成。\n\n### 三色标记法(恢复与暂停)\n\n在引入三色标记法之前的GC标记只是将活动的变量标记为黑色，不活动的变量标记为白色，当GC标记过程结束之后，系统会回收掉所有的白色标记变量，但是这种非黑即白的方法虽然清除起来非常方便但是存在一个问题执行一段时间之后无法知道执行到了哪里，不能进行暂停。所以V8又引入了一个灰色进行暂停和恢复操作。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41fda88ed208434d800a1f258be59f4d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n如图所示，在GC标记开始时所有对象都是白色的，然后从根对象开始进行标记，先将这组对象标记为灰色然后进行记录，如果此时进行中断，后续恢复时既从灰色标记时开始即可，当回收器从标记工作表中弹出对象并访问他们的引用对象时，会将灰色置为黑色，同时将下一个引用对象置为灰色，继续往下进行标记工作。直至无可标记为灰色对象为止，此时表示GC标记过程结束，将所有未标记的变量进行回收工作。所以三色标记法可以渐进执行而不用每次执行都要全盘进行扫描整个内存空间，可以配合增量回收减少全停顿时间，提升体验\n\n### 写屏障\n\n在一次完成GC标记暂停中，如果执行任务程序时内存中存在的变量引用关系被改变了，这样会导致此次GC存在问题。所以V8团队提出了写屏障作为保护。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36a75580ea724bdabffce8fbcedd0c17~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n如图所示，现有A、B、C三个对象依次被引用，且在GC过程中已经被标记了，但是在暂停GC任务，插入执行程序任务之后，引用关系被改变了，新增了一个新变量D，但是此时程序中也未存在灰色标记的变量，下一步进行清除机制时，新变量D按清除机制来讲是要被清除掉，但是这是极其不合理的，一个新的变量还存在引用就被回收掉，这会导致程序云行报错。此时写屏障机制就派上用场了，一旦有黑色的对象引用白色的对象，就会强制将被引用的白色变量标记为灰色，保证下一次的增量GC正确运行，这个机制称为强三色不变性(白色变量D被黑色变量B引用之后会被强制置灰保证程序运行正确性)。\n\n### 惰性清理\n\n在增量GC标记之后下一步就是来真正回收内存空间，通过惰性清理来进行清除释放内存。惰性清理机制运行原理是在进行回收时如果内存足够就可以将这个回收清理时间稍微延迟一下，让JavaScript脚本先执行，清理时也不会一下全部清理掉所有的垃圾，会根据按需进行清理直至所有垃圾都回收完毕，然后继续等待下个GC标记阶段执行结束。\n\n### 并发回收\n\n虽然增量标记和惰性清理的出现使主线程停顿时间大大减少了，但是总体的停顿时间其实并未减少，如果真正细算起来甚至还增加了，应用程序的吞吐量也被降低，不过用户和浏览器的交互体验大大提升牺牲也是值得的。但是后续V8团队为了使回收更加高效， 又使用了并发回收机制，他是在主线程在执行程序任务时，主动开启辅助线程进行GC回收。而主线程又可以自由执行而不会挂起(标记操作全部由辅助进程操作)。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dab8f88e33e94c038f73b57e268c58b5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n# 总结\n\n综合上文的知识点V8引擎的垃圾回收机制也逐渐揭开:分代式策略是V8里面垃圾回收机制的中流砥柱， 只不过老生代的垃圾回收略显麻烦为了优化性能和体验开发团队煞费苦心，在GC标记阶段通过并发回收策略开启辅助线程完成标记操作，清理操作时通过增量任务和惰性回收策略进行清理(同时也会开启辅助线程进行清理)大大提升了回收效率提高了人机交互的体验感。不得不说当下web式应用程序能够飞速发展少不了V8引擎的一份力\n\n","slug":"垃圾回收机制","published":1,"date":"2023-02-03T10:02:00.764Z","updated":"2023-02-06T03:30:37.974Z","_id":"cldqt8vn40000jps6cgvt9fle","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"浏览器垃圾的产生\"><a href=\"#浏览器垃圾的产生\" class=\"headerlink\" title=\"浏览器垃圾的产生\"></a>浏览器垃圾的产生</h1><p>首先，我们要先明白在js中内存垃圾的定义是什么，在js内存管理策略中它会对失去<strong>可达性</strong>(无引用或者无法通过某种方式进行访问)的空间进行回收。既失去可达性的内存空间会被视为是垃圾<br>在正常开发中，我们不可避免的会在程序中进行各种变量声明函数创建等操作，这些操作无疑都是需要从浏览器处进行内存申请，浏览器进行内存分配，但是如果我们在使用引用类型变量时更改了其引用地址，就导致之前被引用的堆地址失去可达性而被白白占用(参考下面代码例子)，如果变量变多这种被白白占用的地址会越来越多，导致新的变量能分配使用的内存会越来越小，系统运行速度会越来越慢，达到临界值时会导致系统崩溃</p>\n<pre><code class=\"javascript\"> let test = &#123;\n    a: 1,\n    b: 2\n\n  &#125;\n  // 上方引用地址无变量引用导致白白占用内存空间\n  test = [1, 2, 3, 4, 6]\n</code></pre>\n<h1 id=\"垃圾回收机制\"><a href=\"#垃圾回收机制\" class=\"headerlink\" title=\"垃圾回收机制\"></a>垃圾回收机制</h1><p>由上文我们可以知道浏览器在运行程序时就会产生垃圾，但是正常情况我们开发时也从未主动去回收垃圾，那程序为何依旧能正常运作呢。那是因为JavaScript自己内部会定时(实时太消耗性能)通过GC(Garbage Collection)进行垃圾回收</p>\n<h2 id=\"垃圾回收策略\"><a href=\"#垃圾回收策略\" class=\"headerlink\" title=\"垃圾回收策略\"></a>垃圾回收策略</h2><p>而在GC中常用的回收策略</p>\n<h3 id=\"标记清除-Mark-Sweep\"><a href=\"#标记清除-Mark-Sweep\" class=\"headerlink\" title=\"标记清除(Mark-Sweep)\"></a>标记清除(Mark-Sweep)</h3><p>标记清除是JavaScript引擎中进行垃圾回收中使用到最多的算法，在目前主流的浏览器厂商中几乎都是可以看到标记清除算法，只不过不同浏览器厂商优化不同，而且不同的浏览器上运行的性能也有差异<br> 而此算法主要核心分为两部分标记和清除<br> 在代码执行阶段，为程序中所有的变量添加上一个二进制字符(二进制运算最快)并初始值置为0(默认全是垃圾)，然后遍历所有的对象，被使用的变量标记置为1，在程序运行结束时回收掉所有标记为零的变量，回收结束之后将现存变量标记统一置为0，等待下一轮回收开启</p>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p>标记清除算法思路清晰，实现比较简单</p>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>由于系统分配的内存时间不同，回收的先后顺序也是不同的，这时就会导致剩余空闲空间并不是连续的，出现了内存碎片现象</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45958c664c3c4f37ab84db61840756b8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"image.png\"></p>\n<p>内存碎片化之后，新的分配空间被分配时需要先计算一下满足符合要求的空间，增加了计算负担。同时如果后续系统需要分配的新变量使用空间很大，虽然系统总剩余内存是满足需求，但是并没有连续的满足需求的空间进行分配，这时可能会出现分配失败</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d7cb0228d2d4a399682271391c2d4af~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"image.png\"></p>\n<p>所以虽然标记清除算法比较简单但是缺点也是很明显由于内存碎片的诞生导致的分配时间较长和空间浪费，所以只要解决掉内存碎片这个致命问题，这两个问题就会迎刃而解<br> 这时候 <strong>标记整理</strong> (Mark-Compact)算法闪亮登场，他的清除逻辑和标记清除算法基本相似不过进行了优化，会在清除结束之后讲活着的空间进行整理向一端移动，同时清理掉内存的边界</p>\n<h3 id=\"引用计数\"><a href=\"#引用计数\" class=\"headerlink\" title=\"引用计数\"></a>引用计数</h3><p>引用计数算法顾名思义，他的策略就是跟踪记录每个变量值被使用的次数，如果一个引用类型的值给一个声明的变量赋值，则将这个引用类型的值的引用次数为1，如果同一个值被又被赋值给另一个变量，则引用计数再加1，如果之前被赋值的变量值变更成了其他引用类型，则原本的引用类型引用计数减1，如果这个引用类型的引用计数为0时表示，此时为不可达状态，浏览器垃圾回收器就将此类型占用的空间进行回收掉(此处是实时的，当计数变为0既会被立即回收)</p>\n<h4 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p>1、实时回收，引用计数当归零就立即进行回收操作。 2、不会暂停执行栈，标记清除算法定时进行垃圾回收时会先暂停程序运行，来进行垃圾回收，而引用计数是实时回收不会暂停程序的运行</p>\n<h4 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>1、空间浪费，由于需要进行计数，所以需要开辟空间来存储计数器，同时由于引用无上限故占用空间也是无上限。 2、无法解决循环引用无法回收(致命问题)，循环引用既两个引用类型AB，A有一个地址指向了B,B也有一个对象指向了A,导致两者引用计数为2，正常情况下当test函数运行结束进行垃圾回收，但是AB两者的基数都不是0则回收失败，无法清除，这种情况大量发生时会造成大量的内存空间被浪费，故引用计数算法现在已经很少使用逐渐被标记清除算法替代</p>\n<pre><code class=\"css\">  function test() &#123;\n    let A = new Object()\n    let B = new Object()\n    B.a = A\n    A.b = B\n  &#125;\n</code></pre>\n<h1 id=\"V8对GC的优化\"><a href=\"#V8对GC的优化\" class=\"headerlink\" title=\"V8对GC的优化\"></a>V8对GC的优化</h1><h2 id=\"分代式优化\"><a href=\"#分代式优化\" class=\"headerlink\" title=\"分代式优化\"></a>分代式优化</h2><p>之前GC的清除算法无论是标记清除还是标记整理，在进行回收时都需要检查内存中的所有对象，但是如果存在一些，体积大，存活时间长，创建早的内存来进行检查，相当于是做了无用功，而新创建，体积小和存活时间短的对象需要更加频繁的检查所以基于这个问题V8提出了新生代和老生代的优化策略。将内存空间划分为新生代和老生代两个部分，不同部分执行不同的回收策略。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79967c264db445d2a0b7474d5785ee13~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"image.png\"></p>\n<h3 id=\"新生代\"><a href=\"#新生代\" class=\"headerlink\" title=\"新生代\"></a>新生代</h3><p>顾名思义新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 1～8M 的容量。 而新生代中的内存又会被拆分为两部分，使用区和空闲区，浏览器进行内存申请时分配使用区空间，当使用区空间快被写满时则进行一次垃圾回收，新生代的垃圾回收器会对使用区的活动对象进行标记，标记完成之后将使用区活跃的对象复制到空闲区，并进行排序，随后进入垃圾清理阶段，对使用区进行清理，清理操作完成之后，使用区和空闲区进行角色互换，之前的空闲区变成新的使用区，之前的使用区变成新的空闲区，循环往复。</p>\n<p>当一个对象被多次复制还未被清理掉，故此对象会被认定为生命周期较长的对象，会被从新生代移动到老生代中，采用老生代的垃圾回收机制管理。</p>\n<p>不过还需要注意一个特殊情况，如果新生代的复制一个对象到空闲区，如果空闲区的使用空间超过25%之后这个对象会被立即复制到老生代，而25%的红线要求是为了保证进行空闲区和使用区翻转时对于新的对象分配空间操作不会被影响。</p>\n<h3 id=\"老生代\"><a href=\"#老生代\" class=\"headerlink\" title=\"老生代\"></a>老生代</h3><p>相比于新生代，老生代顾名思义存放的就是一些生命周期比较长，经过多次新生代垃圾回收还存在的对象，同样的相比于新生代不仅垃圾回收频率较低，存储空间也是比新生代大的多。而老生代的回收算法就比较简单就是标记清除算法，不过在v8中为了处理标记清除算法产生的内存碎片问题，使用了标记整理算法进行空间优化大大提高了回收效率。</p>\n<h2 id=\"并行回收\"><a href=\"#并行回收\" class=\"headerlink\" title=\"并行回收\"></a>并行回收</h2><p>众所周知JavaScript是一门单线程语言，所以在进行GC回收时会阻塞js脚本的运行导致系统停顿，等GC回收结束后恢复运行，这被称为全停顿。</p>\n<p>但是这样的话会存在极大的风险，如果GC回收时间较长，就会导致系统停顿时间较长这是不可被接受的。所以V8引擎加入了并行回收的优化机制，在开启GC回收线程之后，会同时开启多个辅助线程进行处理，提高回处理时间，虽然增加了一部分线程之间协调的时间，但是总时间比一个线程用时来讲大大的缩短。避免系统卡顿时间过长。</p>\n<h2 id=\"增量标记\"><a href=\"#增量标记\" class=\"headerlink\" title=\"增量标记\"></a>增量标记</h2><p>由于全停顿标记策略在处理老生代垃圾回收时即使是有并行处理优化但是消耗时间也会消耗大量的时间，所以在2011年时V8团队又提出了增量标记策略来进行优化。<br> 增量标记思想就是将一次GC标记过程进行拆分，一次执行一小部分，执行完毕后继续执行脚本，执行一段脚本之后又继续执行刚刚拆分的GC标记任务，循环往复直至这次GC标记完成。</p>\n<h3 id=\"三色标记法-恢复与暂停\"><a href=\"#三色标记法-恢复与暂停\" class=\"headerlink\" title=\"三色标记法(恢复与暂停)\"></a>三色标记法(恢复与暂停)</h3><p>在引入三色标记法之前的GC标记只是将活动的变量标记为黑色，不活动的变量标记为白色，当GC标记过程结束之后，系统会回收掉所有的白色标记变量，但是这种非黑即白的方法虽然清除起来非常方便但是存在一个问题执行一段时间之后无法知道执行到了哪里，不能进行暂停。所以V8又引入了一个灰色进行暂停和恢复操作。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41fda88ed208434d800a1f258be59f4d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"image.png\"></p>\n<p>如图所示，在GC标记开始时所有对象都是白色的，然后从根对象开始进行标记，先将这组对象标记为灰色然后进行记录，如果此时进行中断，后续恢复时既从灰色标记时开始即可，当回收器从标记工作表中弹出对象并访问他们的引用对象时，会将灰色置为黑色，同时将下一个引用对象置为灰色，继续往下进行标记工作。直至无可标记为灰色对象为止，此时表示GC标记过程结束，将所有未标记的变量进行回收工作。所以三色标记法可以渐进执行而不用每次执行都要全盘进行扫描整个内存空间，可以配合增量回收减少全停顿时间，提升体验</p>\n<h3 id=\"写屏障\"><a href=\"#写屏障\" class=\"headerlink\" title=\"写屏障\"></a>写屏障</h3><p>在一次完成GC标记暂停中，如果执行任务程序时内存中存在的变量引用关系被改变了，这样会导致此次GC存在问题。所以V8团队提出了写屏障作为保护。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36a75580ea724bdabffce8fbcedd0c17~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"image.png\"></p>\n<p>如图所示，现有A、B、C三个对象依次被引用，且在GC过程中已经被标记了，但是在暂停GC任务，插入执行程序任务之后，引用关系被改变了，新增了一个新变量D，但是此时程序中也未存在灰色标记的变量，下一步进行清除机制时，新变量D按清除机制来讲是要被清除掉，但是这是极其不合理的，一个新的变量还存在引用就被回收掉，这会导致程序云行报错。此时写屏障机制就派上用场了，一旦有黑色的对象引用白色的对象，就会强制将被引用的白色变量标记为灰色，保证下一次的增量GC正确运行，这个机制称为强三色不变性(白色变量D被黑色变量B引用之后会被强制置灰保证程序运行正确性)。</p>\n<h3 id=\"惰性清理\"><a href=\"#惰性清理\" class=\"headerlink\" title=\"惰性清理\"></a>惰性清理</h3><p>在增量GC标记之后下一步就是来真正回收内存空间，通过惰性清理来进行清除释放内存。惰性清理机制运行原理是在进行回收时如果内存足够就可以将这个回收清理时间稍微延迟一下，让JavaScript脚本先执行，清理时也不会一下全部清理掉所有的垃圾，会根据按需进行清理直至所有垃圾都回收完毕，然后继续等待下个GC标记阶段执行结束。</p>\n<h3 id=\"并发回收\"><a href=\"#并发回收\" class=\"headerlink\" title=\"并发回收\"></a>并发回收</h3><p>虽然增量标记和惰性清理的出现使主线程停顿时间大大减少了，但是总体的停顿时间其实并未减少，如果真正细算起来甚至还增加了，应用程序的吞吐量也被降低，不过用户和浏览器的交互体验大大提升牺牲也是值得的。但是后续V8团队为了使回收更加高效， 又使用了并发回收机制，他是在主线程在执行程序任务时，主动开启辅助线程进行GC回收。而主线程又可以自由执行而不会挂起(标记操作全部由辅助进程操作)。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dab8f88e33e94c038f73b57e268c58b5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"image.png\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>综合上文的知识点V8引擎的垃圾回收机制也逐渐揭开:分代式策略是V8里面垃圾回收机制的中流砥柱， 只不过老生代的垃圾回收略显麻烦为了优化性能和体验开发团队煞费苦心，在GC标记阶段通过并发回收策略开启辅助线程完成标记操作，清理操作时通过增量任务和惰性回收策略进行清理(同时也会开启辅助线程进行清理)大大提升了回收效率提高了人机交互的体验感。不得不说当下web式应用程序能够飞速发展少不了V8引擎的一份力</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"浏览器垃圾的产生\"><a href=\"#浏览器垃圾的产生\" class=\"headerlink\" title=\"浏览器垃圾的产生\"></a>浏览器垃圾的产生</h1><p>首先，我们要先明白在js中内存垃圾的定义是什么，在js内存管理策略中它会对失去<strong>可达性</strong>(无引用或者无法通过某种方式进行访问)的空间进行回收。既失去可达性的内存空间会被视为是垃圾<br>在正常开发中，我们不可避免的会在程序中进行各种变量声明函数创建等操作，这些操作无疑都是需要从浏览器处进行内存申请，浏览器进行内存分配，但是如果我们在使用引用类型变量时更改了其引用地址，就导致之前被引用的堆地址失去可达性而被白白占用(参考下面代码例子)，如果变量变多这种被白白占用的地址会越来越多，导致新的变量能分配使用的内存会越来越小，系统运行速度会越来越慢，达到临界值时会导致系统崩溃</p>\n<pre><code class=\"javascript\"> let test = &#123;\n    a: 1,\n    b: 2\n\n  &#125;\n  // 上方引用地址无变量引用导致白白占用内存空间\n  test = [1, 2, 3, 4, 6]\n</code></pre>\n<h1 id=\"垃圾回收机制\"><a href=\"#垃圾回收机制\" class=\"headerlink\" title=\"垃圾回收机制\"></a>垃圾回收机制</h1><p>由上文我们可以知道浏览器在运行程序时就会产生垃圾，但是正常情况我们开发时也从未主动去回收垃圾，那程序为何依旧能正常运作呢。那是因为JavaScript自己内部会定时(实时太消耗性能)通过GC(Garbage Collection)进行垃圾回收</p>\n<h2 id=\"垃圾回收策略\"><a href=\"#垃圾回收策略\" class=\"headerlink\" title=\"垃圾回收策略\"></a>垃圾回收策略</h2><p>而在GC中常用的回收策略</p>\n<h3 id=\"标记清除-Mark-Sweep\"><a href=\"#标记清除-Mark-Sweep\" class=\"headerlink\" title=\"标记清除(Mark-Sweep)\"></a>标记清除(Mark-Sweep)</h3><p>标记清除是JavaScript引擎中进行垃圾回收中使用到最多的算法，在目前主流的浏览器厂商中几乎都是可以看到标记清除算法，只不过不同浏览器厂商优化不同，而且不同的浏览器上运行的性能也有差异<br> 而此算法主要核心分为两部分标记和清除<br> 在代码执行阶段，为程序中所有的变量添加上一个二进制字符(二进制运算最快)并初始值置为0(默认全是垃圾)，然后遍历所有的对象，被使用的变量标记置为1，在程序运行结束时回收掉所有标记为零的变量，回收结束之后将现存变量标记统一置为0，等待下一轮回收开启</p>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p>标记清除算法思路清晰，实现比较简单</p>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>由于系统分配的内存时间不同，回收的先后顺序也是不同的，这时就会导致剩余空闲空间并不是连续的，出现了内存碎片现象</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45958c664c3c4f37ab84db61840756b8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"image.png\"></p>\n<p>内存碎片化之后，新的分配空间被分配时需要先计算一下满足符合要求的空间，增加了计算负担。同时如果后续系统需要分配的新变量使用空间很大，虽然系统总剩余内存是满足需求，但是并没有连续的满足需求的空间进行分配，这时可能会出现分配失败</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d7cb0228d2d4a399682271391c2d4af~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"image.png\"></p>\n<p>所以虽然标记清除算法比较简单但是缺点也是很明显由于内存碎片的诞生导致的分配时间较长和空间浪费，所以只要解决掉内存碎片这个致命问题，这两个问题就会迎刃而解<br> 这时候 <strong>标记整理</strong> (Mark-Compact)算法闪亮登场，他的清除逻辑和标记清除算法基本相似不过进行了优化，会在清除结束之后讲活着的空间进行整理向一端移动，同时清理掉内存的边界</p>\n<h3 id=\"引用计数\"><a href=\"#引用计数\" class=\"headerlink\" title=\"引用计数\"></a>引用计数</h3><p>引用计数算法顾名思义，他的策略就是跟踪记录每个变量值被使用的次数，如果一个引用类型的值给一个声明的变量赋值，则将这个引用类型的值的引用次数为1，如果同一个值被又被赋值给另一个变量，则引用计数再加1，如果之前被赋值的变量值变更成了其他引用类型，则原本的引用类型引用计数减1，如果这个引用类型的引用计数为0时表示，此时为不可达状态，浏览器垃圾回收器就将此类型占用的空间进行回收掉(此处是实时的，当计数变为0既会被立即回收)</p>\n<h4 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p>1、实时回收，引用计数当归零就立即进行回收操作。 2、不会暂停执行栈，标记清除算法定时进行垃圾回收时会先暂停程序运行，来进行垃圾回收，而引用计数是实时回收不会暂停程序的运行</p>\n<h4 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>1、空间浪费，由于需要进行计数，所以需要开辟空间来存储计数器，同时由于引用无上限故占用空间也是无上限。 2、无法解决循环引用无法回收(致命问题)，循环引用既两个引用类型AB，A有一个地址指向了B,B也有一个对象指向了A,导致两者引用计数为2，正常情况下当test函数运行结束进行垃圾回收，但是AB两者的基数都不是0则回收失败，无法清除，这种情况大量发生时会造成大量的内存空间被浪费，故引用计数算法现在已经很少使用逐渐被标记清除算法替代</p>\n<pre><code class=\"css\">  function test() &#123;\n    let A = new Object()\n    let B = new Object()\n    B.a = A\n    A.b = B\n  &#125;\n</code></pre>\n<h1 id=\"V8对GC的优化\"><a href=\"#V8对GC的优化\" class=\"headerlink\" title=\"V8对GC的优化\"></a>V8对GC的优化</h1><h2 id=\"分代式优化\"><a href=\"#分代式优化\" class=\"headerlink\" title=\"分代式优化\"></a>分代式优化</h2><p>之前GC的清除算法无论是标记清除还是标记整理，在进行回收时都需要检查内存中的所有对象，但是如果存在一些，体积大，存活时间长，创建早的内存来进行检查，相当于是做了无用功，而新创建，体积小和存活时间短的对象需要更加频繁的检查所以基于这个问题V8提出了新生代和老生代的优化策略。将内存空间划分为新生代和老生代两个部分，不同部分执行不同的回收策略。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79967c264db445d2a0b7474d5785ee13~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"image.png\"></p>\n<h3 id=\"新生代\"><a href=\"#新生代\" class=\"headerlink\" title=\"新生代\"></a>新生代</h3><p>顾名思义新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 1～8M 的容量。 而新生代中的内存又会被拆分为两部分，使用区和空闲区，浏览器进行内存申请时分配使用区空间，当使用区空间快被写满时则进行一次垃圾回收，新生代的垃圾回收器会对使用区的活动对象进行标记，标记完成之后将使用区活跃的对象复制到空闲区，并进行排序，随后进入垃圾清理阶段，对使用区进行清理，清理操作完成之后，使用区和空闲区进行角色互换，之前的空闲区变成新的使用区，之前的使用区变成新的空闲区，循环往复。</p>\n<p>当一个对象被多次复制还未被清理掉，故此对象会被认定为生命周期较长的对象，会被从新生代移动到老生代中，采用老生代的垃圾回收机制管理。</p>\n<p>不过还需要注意一个特殊情况，如果新生代的复制一个对象到空闲区，如果空闲区的使用空间超过25%之后这个对象会被立即复制到老生代，而25%的红线要求是为了保证进行空闲区和使用区翻转时对于新的对象分配空间操作不会被影响。</p>\n<h3 id=\"老生代\"><a href=\"#老生代\" class=\"headerlink\" title=\"老生代\"></a>老生代</h3><p>相比于新生代，老生代顾名思义存放的就是一些生命周期比较长，经过多次新生代垃圾回收还存在的对象，同样的相比于新生代不仅垃圾回收频率较低，存储空间也是比新生代大的多。而老生代的回收算法就比较简单就是标记清除算法，不过在v8中为了处理标记清除算法产生的内存碎片问题，使用了标记整理算法进行空间优化大大提高了回收效率。</p>\n<h2 id=\"并行回收\"><a href=\"#并行回收\" class=\"headerlink\" title=\"并行回收\"></a>并行回收</h2><p>众所周知JavaScript是一门单线程语言，所以在进行GC回收时会阻塞js脚本的运行导致系统停顿，等GC回收结束后恢复运行，这被称为全停顿。</p>\n<p>但是这样的话会存在极大的风险，如果GC回收时间较长，就会导致系统停顿时间较长这是不可被接受的。所以V8引擎加入了并行回收的优化机制，在开启GC回收线程之后，会同时开启多个辅助线程进行处理，提高回处理时间，虽然增加了一部分线程之间协调的时间，但是总时间比一个线程用时来讲大大的缩短。避免系统卡顿时间过长。</p>\n<h2 id=\"增量标记\"><a href=\"#增量标记\" class=\"headerlink\" title=\"增量标记\"></a>增量标记</h2><p>由于全停顿标记策略在处理老生代垃圾回收时即使是有并行处理优化但是消耗时间也会消耗大量的时间，所以在2011年时V8团队又提出了增量标记策略来进行优化。<br> 增量标记思想就是将一次GC标记过程进行拆分，一次执行一小部分，执行完毕后继续执行脚本，执行一段脚本之后又继续执行刚刚拆分的GC标记任务，循环往复直至这次GC标记完成。</p>\n<h3 id=\"三色标记法-恢复与暂停\"><a href=\"#三色标记法-恢复与暂停\" class=\"headerlink\" title=\"三色标记法(恢复与暂停)\"></a>三色标记法(恢复与暂停)</h3><p>在引入三色标记法之前的GC标记只是将活动的变量标记为黑色，不活动的变量标记为白色，当GC标记过程结束之后，系统会回收掉所有的白色标记变量，但是这种非黑即白的方法虽然清除起来非常方便但是存在一个问题执行一段时间之后无法知道执行到了哪里，不能进行暂停。所以V8又引入了一个灰色进行暂停和恢复操作。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41fda88ed208434d800a1f258be59f4d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"image.png\"></p>\n<p>如图所示，在GC标记开始时所有对象都是白色的，然后从根对象开始进行标记，先将这组对象标记为灰色然后进行记录，如果此时进行中断，后续恢复时既从灰色标记时开始即可，当回收器从标记工作表中弹出对象并访问他们的引用对象时，会将灰色置为黑色，同时将下一个引用对象置为灰色，继续往下进行标记工作。直至无可标记为灰色对象为止，此时表示GC标记过程结束，将所有未标记的变量进行回收工作。所以三色标记法可以渐进执行而不用每次执行都要全盘进行扫描整个内存空间，可以配合增量回收减少全停顿时间，提升体验</p>\n<h3 id=\"写屏障\"><a href=\"#写屏障\" class=\"headerlink\" title=\"写屏障\"></a>写屏障</h3><p>在一次完成GC标记暂停中，如果执行任务程序时内存中存在的变量引用关系被改变了，这样会导致此次GC存在问题。所以V8团队提出了写屏障作为保护。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36a75580ea724bdabffce8fbcedd0c17~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"image.png\"></p>\n<p>如图所示，现有A、B、C三个对象依次被引用，且在GC过程中已经被标记了，但是在暂停GC任务，插入执行程序任务之后，引用关系被改变了，新增了一个新变量D，但是此时程序中也未存在灰色标记的变量，下一步进行清除机制时，新变量D按清除机制来讲是要被清除掉，但是这是极其不合理的，一个新的变量还存在引用就被回收掉，这会导致程序云行报错。此时写屏障机制就派上用场了，一旦有黑色的对象引用白色的对象，就会强制将被引用的白色变量标记为灰色，保证下一次的增量GC正确运行，这个机制称为强三色不变性(白色变量D被黑色变量B引用之后会被强制置灰保证程序运行正确性)。</p>\n<h3 id=\"惰性清理\"><a href=\"#惰性清理\" class=\"headerlink\" title=\"惰性清理\"></a>惰性清理</h3><p>在增量GC标记之后下一步就是来真正回收内存空间，通过惰性清理来进行清除释放内存。惰性清理机制运行原理是在进行回收时如果内存足够就可以将这个回收清理时间稍微延迟一下，让JavaScript脚本先执行，清理时也不会一下全部清理掉所有的垃圾，会根据按需进行清理直至所有垃圾都回收完毕，然后继续等待下个GC标记阶段执行结束。</p>\n<h3 id=\"并发回收\"><a href=\"#并发回收\" class=\"headerlink\" title=\"并发回收\"></a>并发回收</h3><p>虽然增量标记和惰性清理的出现使主线程停顿时间大大减少了，但是总体的停顿时间其实并未减少，如果真正细算起来甚至还增加了，应用程序的吞吐量也被降低，不过用户和浏览器的交互体验大大提升牺牲也是值得的。但是后续V8团队为了使回收更加高效， 又使用了并发回收机制，他是在主线程在执行程序任务时，主动开启辅助线程进行GC回收。而主线程又可以自由执行而不会挂起(标记操作全部由辅助进程操作)。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dab8f88e33e94c038f73b57e268c58b5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"image.png\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>综合上文的知识点V8引擎的垃圾回收机制也逐渐揭开:分代式策略是V8里面垃圾回收机制的中流砥柱， 只不过老生代的垃圾回收略显麻烦为了优化性能和体验开发团队煞费苦心，在GC标记阶段通过并发回收策略开启辅助线程完成标记操作，清理操作时通过增量任务和惰性回收策略进行清理(同时也会开启辅助线程进行清理)大大提升了回收效率提高了人机交互的体验感。不得不说当下web式应用程序能够飞速发展少不了V8引擎的一份力</p>\n"},{"title":"React中的Diff算法","cover":"https://www.python51.com/wp-content/uploads/2022/12/20221216-70.png","_content":"\n# 前置知识：虚拟 DOM\n\n虚拟 DOM 节点是一个 JS 对象，用这个 JS 对象可以表示 DOM 节点、组件节点等，创建一个虚拟 DOM 节点比创建一个 DOM 节点的代价要小很多。有了虚拟 DOM，能提高我们的研发体验和效率，同时也能解决跨平台的问题\n\n在 Vue 中，通常用 VNode 指代一个虚拟 DOM 节点，我们最终会根据 VNode 生成 DOM 节点. 在 React 中，通过 React.createElement 也能生成一个虚拟 DOM 节点（ReactElement）\n\n# React中的DOM架构\n\n在 React15 及以前，采用了递归的方式创建虚拟 DOM，递归过程是不能中断的。如果组件树的层级很深，递归会占用线程很多时间，造成卡顿。React16 将递归的无法中断的更新重构为异步的可中断更新，推出了新的 Fiber 架构\n\n原本的 ReactElement 只有 children，在中断恢复时，无法找到其兄弟节点和父节点，无法从断点处继续完成渲染工作。而 fiber 节点上能访问到父节点、子节点、兄弟节点，所以即使渲染被打断了，也可以恢复查找未处理的节点。因此，React 需要先生成 ReactElement，再生成 fiber，最后才将变更映射到真实 DOM 节点。这一点和 Vue 有很大不同\n\nReact 采用了双缓存的技术，在 React 中最多会存在两颗 fiber 树，当前屏幕上显示内容对应的 fiber 树称为 current fiber 树，正在内存中构建的 fiber 树称为 workInProgress fiber 树。当 workInProgress fiber 树构建并渲染到页面上后，应用根节点的 current 指针指向 workInProgress Fiber 树，此时workInProgress Fiber 树就变为 current Fiber 树\n\n假设我们有这样一段代码：\n\n```react\nconst App = () => {\n  const [count, setCount] = React.useState(0)\n  return <div onClick={() => setCount(n => n + 1)}>{count}</div>\n}\n\nReactDOM.createRoot(document.getElementById('root')).render(<App />)\n```\n\n那么，对应的 fiber 树会经历如下图所示的变化过程：\n\n<img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ccc58df27154105b150ee9a7a24ba10~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?\" alt=\"UML 图.jpg \" style=\"zoom:67%;\" />\n\nReact 的更新会经历两个阶段：render 阶段 和 commit 阶段。render 阶段是可中断的，commit 阶段是不可中断的\n\nrender 阶段会生成 fiber 树，所谓的 diff 就会发生在这个阶段。React 通过深度优先遍历来生成 fiber 树，整个过程与递归是类似的，因此生成 fiber 树的过程又可以分为「递」阶段和「归」阶段\n\ncommit 阶段主要执行各种 DOM 操作、生命周期钩子、某些 hook 等\n\n因此，diff 阶段不会直接变更 DOM，而是留到 commit 阶段再做变更\n\nVue 与 React 不同，它通过递归的形式生成整个虚拟 DOM 树，在 diff 的同时会对 DOM 做变更\n\n# React 18中简单diff算法\n\nReact 每次更新时，会将新的 ReactElement（即 React.createElement() 的返回值）与旧的 fiber 树作对比，比较出它们的差异后，构建出新的 fiber 树，因此多节点的diff实际上是用 fiber（旧子节点）和 ReactElement 数组（新子节点）进行对比\n\n## 第一轮遍历\n\nReact 团队发现，在实际的场景中，更新节点的情况要大于新增和删除节点的情况，因此第一轮遍历会先尝试更新子节点\n\n遍历逻辑如下：\n\n如果新旧子节点的 key 和 type（节点类型，如 div、p、span、函数组件名）都相同，则根据旧 fiber 和 新 ReactElement 的 props 生成新子节点 fiber\n\n如果新旧子节点的 key 相同，但 type 不同，将根据新 ReactElement 生成新 fiber，旧 fiber 将被添加到它的父级 fiber 的 deletions 数组中，后续将被移除\n\n如果新旧子节点的 key 和 type 都不相同，结束遍历\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72f401ece31e418f86c1e40206eb9117~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?\" alt=\"UML 图 (1).jpg \" style=\"zoom:67%;\" />\n\n## 第二轮遍历\n\n如果第一轮遍历被提前终止了，意味着还有新 ReactElement 或 旧 fiber 还未被遍历。因此会有第二轮遍历去处理以下三种情况：\n\n只剩旧子节点\n\n只剩新子节点\n\n新旧子节点都有剩\n\n下图分别展示了这三种情况：\n\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84d81f81ddf54fe59a989a48356ff8e3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?\" alt=\"UML 图 (2).jpg \" style=\"zoom:67%;\" />\n\n### 第一种情况: 只剩旧子节点\n\n只剩下旧子节点的处理方法很简单，只需要将剩余的旧 fiber 放到父 fiber 的 deletions 数组中，这些旧 fiber 对应的 DOM 节点将会在 commit 阶段被移除\n\n![UML 图 (3).jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ed4b64494db48eb953c216c70feeff7~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n### 第二种情况: 只剩新子节点\n\n对于剩余的新子节点，先创建新的 fiber 节点，然后打上 Placement 标记，我们将在遍历 fiber 树的「归」阶段生成这些新 fiber 对应的 DOM 节点\n\n![UML 图 (4).jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d97dac1167024d30bfc5fe8e3ec4d075~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n### 第三种情况: 新旧子节点都有剩\n\n这种情况下，需要一个快速的方法帮助我们快速找到某个 ReactElement 在上一次渲染时生成的 fiber 节点。因此，我们需要一个 existingChildren Map，这个 Map 保存了旧 fiber 的 key 到 旧 fiber 的映射关系，我们可以通过新的 ReactElement 的 key 快速在这个 Map 中找到对应的旧 fiber，如果能找到，则能复用旧 fiber 以生成新 fiber；如果找不到，证明要生成新的 fiber，并打上一个 Placement 标志，以便于在 commit 阶段插入该 fiber 对应的 DOM 节点。\n\n我们还需要找到哪些节点的位置发生了变化\n\n假设我们有 a、b、c、d 四个节点，它们的位置索引是 0、1、2、3，是一个递增的序列。在更新后，它们顺序发生了变化，变成了 a、c、b、d，那么它们的位置索引变为 0、2、1、3（继续沿用旧的位置索引），不再是一个递增的序列，因为索引 1 移到了 2 的后面（即 b 原本在 c 前面，更新后被移到了 c 后面），破坏了递增的规律。因此，只需要找到那些破坏了索引递增规律的节点，就知道哪些节点的位置发生了变化。那具体要怎么做呢？\n\n其实，旧 fiber 上有 index 属性，index 属性记录了在上一次渲染时该 fiber 所在的位置索引。现在，我们暂且叫这个旧 fiber 上的 index 属性为 oldIndex，把遍历新子节点过程中访问过的最大 oldIndex 叫为 lastPlacedIndex，那么，只要当前新子节点有对应的旧 fiber，且 oldIndex < lastPlacedIndex，就可以认为该新子节点对应的 DOM 节点需要往后移动，并打上一个 Placement 标志，以便于在 commit 阶段识别出这个需要移动 DOM 节点的 fiber\n\n遍历逻辑如下：\n\n遍历未处理的旧子节点，生成 existingChildren Map\n\n从前到后遍历新子节点\n\n如果能在 existingChildren Map 中找到对应的旧 fiber，根据旧 fiber 生成新 fiber；如果不能，生成新 fiber，并打上 Placement 标志\n\n从 existingChildren Map 中删除已处理的节点\n\n如果新子节点有对应的旧 fiber\n\n当 oldIndex < lastPlacedIndex 时，给新 fiber 打上 Placement 标志；否则，令 lastPlacedIndex = newIndex\n\n如果新子节点没有对应的旧 fiber，创建一个新 fiber 并 打上 Placement 标志\n\n遍历 existingChildren Map，将 Map 中所有节点添加到父节点的 deletions 数组中\n\n![UML 图 (5).jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f287eb10bb94c4f94e8c710a7606e7f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n## DOM 变更\n\nDOM 元素类型的 fiber 节点上存有对 DOM 节点的引用，因此在 commit 阶段，深度优先遍历每个新 fiber 节点，对 fiber 节点对应的 DOM 节点做以下变更：\n\n1. 删除 deletions 数组中 fiber 对应的 DOM 节点\n\n1. 如有 Placement 标志，将节点移动到往后第一个没有 Placement 标记的fiber的DOM节点之前\n\n1. 更新节点。以 DOM 节点为例，在生成 fiber 树的「归」阶段，会找出属性的变更集，在 commit 阶段更新属性\n\n![UML 图 (6).jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7044fc48726b49389413bcf801aeeb10~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n## 最坏的情况\n\n在处理节点往前移的情况，React 的 diff 算法表现得就不太好了。以下图为例，节点 a、b、c、d 变为了 d、a、b、c，如果我们手动处理这种位置变化，只需要一步：将 d 节点移动到 a 前面。但 React 实际上的做法有三步：将 a、b、c 三个节点依次插入到 d 节点后面\n\n这是因为遍历完 d 节点后，lastPlacedIndex 变成了 3，再去遍历 a、b、c、d 时，oldIndex 一定小于 lastPlacedIndex 了\n\n![UML 图 (7).jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71569a9e6e8045b585b0b1d5c3f100ea~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n因此，实际编写代码时，应该尽量避免节点往前移动的操作\n\n# Vue2中的双端Diff算法\n\nVue2中的双端Diff是旧的一组VNode( 旧子节点 )和新的一组VNode( 新子节点 )进行对比\n\n## 第一轮遍历\n\n所谓的双端, 表示在新旧子节点的数组中, 各用两个指针指向头尾节点, 在遍历过程中, 头尾指针不断靠拢. 因此, 用newStartIndex和newEndIndex分别指向新子节点中未处理的头尾节点, 用oldStartIndex和oldEndIndex分别指向旧子节点中未处理节点的头尾节点\n\n现在, 我们用「新前」表示新子节点中未处理节点的第一个节点; 用「新后」表示新子节点中未处理的最后一个节点; 「旧前」表示旧子节点中未处理节点的第一个节点; 用「旧后」表示旧子节点中未处理节点的最后一个节点\n\n每遍历到一个节点, 就尝试进行双端比较: 「新前 vs 旧前」、「新后 vs 旧后」、「新后 vs 旧前」、「新前 vs 旧后」, 如果匹配成功, 更新双端的指针 . 比如, 新旧子节点通过「新前 vs 旧后」匹配成功，那么 newStartIndex += 1，oldEndIndex -= 1\n\n如果新旧子节点通过「新后 vs 旧前」匹配成功, 还需要将「旧前」对应的DOM节点插入到「旧后」对应的DOM节点之后. 如果新旧节点通过「新前 vs 旧后」, 还需要将「旧后」对应的DOM节点插入到「旧前」对应的DOM节点之前\n\n如果通过双端比较都没法找到匹配的节点, 就需要一个React中的existingChildren Map的Map对象了, 在Vue2的diff中, 这个名字叫做oldKeyToIdx Map. 通过这个Map, 遍历时可以尝试根据新子节点的key去找oldIndex, 查找结果会有两种:\n\n找到oldIndex, 即新旧子节点有相同key的节点\n\n如果VNode的type是相同的, 将旧子节点对应的DOM节点插入到「旧前」对应的DOM节点之前\n\n如果VNode的type是不同的, 创建一个新的DOM节点, 并插入到「旧前」对应的DOM节点之前\n\n没找到oldIndex, 需要根据新子节点(VNode)创建DOM元素, 并插入到「旧前」对应的DOM节点之前\n\n简单来说, 第一轮遍历会先尝试比较新旧子节点的双端节点, 如果匹配不成功, 再尝试在旧子节点中找到对应的节点. 至于DOM节点的移动, 需要记住只能移动到「旧前」之前或「旧后」之后 . 如果更新后节点位置被调到前面了 移动时就需要移动到「旧前」之前; 如果更新后节点位置被调到后面了, 移动时就需要移到「旧后」之后\n\n## 第二轮遍历\n\n如果第一轮遍历后, 只剩下新子节点( newStartIndex>newEndIndex ) , 则根据剩余的新子节点(VNode)创建DOM节点, 并依次插入到父级DOM节点最后\n\n如果第一轮遍历后, 只剩下旧子节点(oldStartIndex>oldEndIndex), 则将剩余旧子节点对应的DOM节点依次从父级DOM节点中删除\n\n需要注意的是, Vue在diff过程中, 会直接进行节点的更新/新建/删除操作, 这点和React是不同的\n\n下面展示了Vue2双端Diff的一些例子, 能够更好的消化理解算法:\n\n![UML 图 (8).jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c45e7a6ad91b49f0ac9ec35e15484359~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n# React为什么不使用双端diff\n\n简单地总结React不使用双端diff的原因: 由于双端diff需要向前查找节点, 但每个fiber节点上都没有反向指针, 即前一个fiber通过sibling属性指向后一个fiber, 只能从前往后遍历, 而不能反过来\n\n# Vue3中的快速Diff算法\n\n注意: Vue3多节点的diff是旧的一组VNode( 旧子节点 ) 和新的一组VNode( 新子节点 )进行对比\n\n## 第一轮遍历\n\n先从新旧子节点的头部节点开始, 一个一个进行对比, 直到遇到不同的节点, 再从新旧子节点的尾部节点开始, 一个一个进行对比, 直到遇到不相同的节点\n\n![UML 图 (9).jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8985f95f59dd4ef083fc5318a39c7708~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n## 第二轮遍历\n\n如果第一轮遍历结束之后还有新子节点或旧子节点未被处理, 那么会有三种情况:\n\n1. 只剩下新子节点         \n2. 只剩下旧子节点          \n3. 新旧子节点都有剩下的\n\n## 第一种情况: 只剩下新子节点\n\n对于剩余的新子节点, 依次创建对应的DOM节点, 并插到尾部已处理节点之前\n\n![UML 图 (10).jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af7e3ca002e04e13a5899893753a5d63~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n## 第二种情况: 只剩下旧子节点\n\n对于剩余的旧子节点，依次从父级 DOM 节点中删除对应的 DOM 节点\n\n![UML 图 (11).jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac8c2b3d4cdf4422a722c36cc9c288cf~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n----\n\n## 第三种情况: 新旧子节点都有剩下的\n\n这种情况下有可能有节点需要移动, 假设旧子节点的位置索引序列是递增序列, 使用新子节点在旧子节点中的位置索引组合成一个位置索引序列, 如果这个序列是非递增序列, 如果这个序列是非递增序列, 那么就肯定存在节点移动的情况. 进一步思考, 可以发现新的位置索引序列中的最大递增子序列是不需要移动的, 其余索引对应的节点才需要移动\n\n因此, 需要引入求解最长递增子序列的算法\n\n求解最长递增子序列：**贪心 + 二分查找**\n\n---\n\n现在让我们通过一个例子来理解处理流程吧\n\n旧子节点\n\n```html\n<div>\n  <div key=\"a\">a</div>\n  <div key=\"b\">b</div>\n  <div key=\"c\">c</div>\n  <div key=\"d\">d</div>\n  <div key=\"f\">f</div>\n  <div key=\"e\">e</div>\n</div>\n```\n\n新子节点\n\n```html\n<div>\n  <div key=\"a\">a</div>\n  <div key=\"c\">c</div>\n  <div key=\"d\">d</div>\n  <div key=\"b\">b</div>\n  <div key=\"g\">g</div>\n  <div key=\"e\">e</div>\n</div>\n```\n\n要求解最长递增子序列我们就先需要一个数组 newIndexToOldIndexMap（虽然源码中叫 Map，但它实际上是一个数组），这个数组表示新的一组子节点中的节点在旧的一组子节点中的位置索引。这个数组中的 0 值表示对应位置索引的新子节点在旧的一组子节点中不存在匹配的节点，证明需要挂载新的 DOM 节点。因此，只要新子节点在旧的一组子节点中能找到匹配的节点，在记录位置索引到 newIndexToOldIndexMap 前，都需要将位置索引做加 1 处理。\n\n为了构造这个 newIndexToOldIndexMap 数组，需要遍历未处理的旧子节点，遍历过程主要做以下事情：\n\n1. 填充 newIndexToOldIndexMap 数组\n\n1. 确定是否存在需要移动的节点。这个结果将用于判断是否需要求解最长递增子序列，在没有节点移动的情况下，能降低时间复杂度。判断方法本质上和 React 是类似的实现原理，Vue 3 将访问过的最大 newIndex（旧子节点在新的一组子节点中的位置索引）记录到一个叫 maxNewIndexSoFar 的变量中，如果当前 newIndex < maxNewIndexSoFar，证明存在需要移动的节点\n\n1. 更新那些能找到对应新子节点的旧子节点\n\n1. 卸载那些找不到对应新子节点的旧子节点\n\n![1101-1.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8cc0ca3ac56c4bcc89157b0989e79334~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n遍历完旧子节点后，数组 newIndexToOldIndexMap 为：[2, 3, 1, 0]，尽管最长递增子序列是 [2, 3]，但我们需要知道哪些位置的节点是不需要移动的，所以得到这样一个叫 increasingNewIndexSequence 的数组：[0, 1]，表示第一和第二个节点是不需要移动的\n\n接下来从后往前遍历新子节点（假设 i 为当前遍历节点的位置索引）：\n\n如果 newIndexToOldIndexMap[i] 为 0，需要新建 DOM 节点，插入到右边新子节点（VNode）的 DOM 节点之前\n\n如果 increasingNewIndexSequence 数组里不包含 i，证明这个新子节点不在最长递增子序列中，需要将它对应的 DOM 节点需要插入到右边新子节点的 DOM 节点之前\n\n如果 increasingNewIndexSequence 数组里包含 i，证明当前新子节点对应的 DOM 节点不需要移动\n\n注意，遍历新子节点时不再需要更新节点，因为在遍历旧子节点时已经更新过了\n\n![UML 图 (12).jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5712293272e342dd8e179183d2e17f6c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/diff算法.md","raw":"---\ntitle: React中的Diff算法\ncategory: React原理\ncover: https://www.python51.com/wp-content/uploads/2022/12/20221216-70.png\n---\n\n# 前置知识：虚拟 DOM\n\n虚拟 DOM 节点是一个 JS 对象，用这个 JS 对象可以表示 DOM 节点、组件节点等，创建一个虚拟 DOM 节点比创建一个 DOM 节点的代价要小很多。有了虚拟 DOM，能提高我们的研发体验和效率，同时也能解决跨平台的问题\n\n在 Vue 中，通常用 VNode 指代一个虚拟 DOM 节点，我们最终会根据 VNode 生成 DOM 节点. 在 React 中，通过 React.createElement 也能生成一个虚拟 DOM 节点（ReactElement）\n\n# React中的DOM架构\n\n在 React15 及以前，采用了递归的方式创建虚拟 DOM，递归过程是不能中断的。如果组件树的层级很深，递归会占用线程很多时间，造成卡顿。React16 将递归的无法中断的更新重构为异步的可中断更新，推出了新的 Fiber 架构\n\n原本的 ReactElement 只有 children，在中断恢复时，无法找到其兄弟节点和父节点，无法从断点处继续完成渲染工作。而 fiber 节点上能访问到父节点、子节点、兄弟节点，所以即使渲染被打断了，也可以恢复查找未处理的节点。因此，React 需要先生成 ReactElement，再生成 fiber，最后才将变更映射到真实 DOM 节点。这一点和 Vue 有很大不同\n\nReact 采用了双缓存的技术，在 React 中最多会存在两颗 fiber 树，当前屏幕上显示内容对应的 fiber 树称为 current fiber 树，正在内存中构建的 fiber 树称为 workInProgress fiber 树。当 workInProgress fiber 树构建并渲染到页面上后，应用根节点的 current 指针指向 workInProgress Fiber 树，此时workInProgress Fiber 树就变为 current Fiber 树\n\n假设我们有这样一段代码：\n\n```react\nconst App = () => {\n  const [count, setCount] = React.useState(0)\n  return <div onClick={() => setCount(n => n + 1)}>{count}</div>\n}\n\nReactDOM.createRoot(document.getElementById('root')).render(<App />)\n```\n\n那么，对应的 fiber 树会经历如下图所示的变化过程：\n\n<img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ccc58df27154105b150ee9a7a24ba10~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?\" alt=\"UML 图.jpg \" style=\"zoom:67%;\" />\n\nReact 的更新会经历两个阶段：render 阶段 和 commit 阶段。render 阶段是可中断的，commit 阶段是不可中断的\n\nrender 阶段会生成 fiber 树，所谓的 diff 就会发生在这个阶段。React 通过深度优先遍历来生成 fiber 树，整个过程与递归是类似的，因此生成 fiber 树的过程又可以分为「递」阶段和「归」阶段\n\ncommit 阶段主要执行各种 DOM 操作、生命周期钩子、某些 hook 等\n\n因此，diff 阶段不会直接变更 DOM，而是留到 commit 阶段再做变更\n\nVue 与 React 不同，它通过递归的形式生成整个虚拟 DOM 树，在 diff 的同时会对 DOM 做变更\n\n# React 18中简单diff算法\n\nReact 每次更新时，会将新的 ReactElement（即 React.createElement() 的返回值）与旧的 fiber 树作对比，比较出它们的差异后，构建出新的 fiber 树，因此多节点的diff实际上是用 fiber（旧子节点）和 ReactElement 数组（新子节点）进行对比\n\n## 第一轮遍历\n\nReact 团队发现，在实际的场景中，更新节点的情况要大于新增和删除节点的情况，因此第一轮遍历会先尝试更新子节点\n\n遍历逻辑如下：\n\n如果新旧子节点的 key 和 type（节点类型，如 div、p、span、函数组件名）都相同，则根据旧 fiber 和 新 ReactElement 的 props 生成新子节点 fiber\n\n如果新旧子节点的 key 相同，但 type 不同，将根据新 ReactElement 生成新 fiber，旧 fiber 将被添加到它的父级 fiber 的 deletions 数组中，后续将被移除\n\n如果新旧子节点的 key 和 type 都不相同，结束遍历\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72f401ece31e418f86c1e40206eb9117~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?\" alt=\"UML 图 (1).jpg \" style=\"zoom:67%;\" />\n\n## 第二轮遍历\n\n如果第一轮遍历被提前终止了，意味着还有新 ReactElement 或 旧 fiber 还未被遍历。因此会有第二轮遍历去处理以下三种情况：\n\n只剩旧子节点\n\n只剩新子节点\n\n新旧子节点都有剩\n\n下图分别展示了这三种情况：\n\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84d81f81ddf54fe59a989a48356ff8e3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?\" alt=\"UML 图 (2).jpg \" style=\"zoom:67%;\" />\n\n### 第一种情况: 只剩旧子节点\n\n只剩下旧子节点的处理方法很简单，只需要将剩余的旧 fiber 放到父 fiber 的 deletions 数组中，这些旧 fiber 对应的 DOM 节点将会在 commit 阶段被移除\n\n![UML 图 (3).jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ed4b64494db48eb953c216c70feeff7~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n### 第二种情况: 只剩新子节点\n\n对于剩余的新子节点，先创建新的 fiber 节点，然后打上 Placement 标记，我们将在遍历 fiber 树的「归」阶段生成这些新 fiber 对应的 DOM 节点\n\n![UML 图 (4).jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d97dac1167024d30bfc5fe8e3ec4d075~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n### 第三种情况: 新旧子节点都有剩\n\n这种情况下，需要一个快速的方法帮助我们快速找到某个 ReactElement 在上一次渲染时生成的 fiber 节点。因此，我们需要一个 existingChildren Map，这个 Map 保存了旧 fiber 的 key 到 旧 fiber 的映射关系，我们可以通过新的 ReactElement 的 key 快速在这个 Map 中找到对应的旧 fiber，如果能找到，则能复用旧 fiber 以生成新 fiber；如果找不到，证明要生成新的 fiber，并打上一个 Placement 标志，以便于在 commit 阶段插入该 fiber 对应的 DOM 节点。\n\n我们还需要找到哪些节点的位置发生了变化\n\n假设我们有 a、b、c、d 四个节点，它们的位置索引是 0、1、2、3，是一个递增的序列。在更新后，它们顺序发生了变化，变成了 a、c、b、d，那么它们的位置索引变为 0、2、1、3（继续沿用旧的位置索引），不再是一个递增的序列，因为索引 1 移到了 2 的后面（即 b 原本在 c 前面，更新后被移到了 c 后面），破坏了递增的规律。因此，只需要找到那些破坏了索引递增规律的节点，就知道哪些节点的位置发生了变化。那具体要怎么做呢？\n\n其实，旧 fiber 上有 index 属性，index 属性记录了在上一次渲染时该 fiber 所在的位置索引。现在，我们暂且叫这个旧 fiber 上的 index 属性为 oldIndex，把遍历新子节点过程中访问过的最大 oldIndex 叫为 lastPlacedIndex，那么，只要当前新子节点有对应的旧 fiber，且 oldIndex < lastPlacedIndex，就可以认为该新子节点对应的 DOM 节点需要往后移动，并打上一个 Placement 标志，以便于在 commit 阶段识别出这个需要移动 DOM 节点的 fiber\n\n遍历逻辑如下：\n\n遍历未处理的旧子节点，生成 existingChildren Map\n\n从前到后遍历新子节点\n\n如果能在 existingChildren Map 中找到对应的旧 fiber，根据旧 fiber 生成新 fiber；如果不能，生成新 fiber，并打上 Placement 标志\n\n从 existingChildren Map 中删除已处理的节点\n\n如果新子节点有对应的旧 fiber\n\n当 oldIndex < lastPlacedIndex 时，给新 fiber 打上 Placement 标志；否则，令 lastPlacedIndex = newIndex\n\n如果新子节点没有对应的旧 fiber，创建一个新 fiber 并 打上 Placement 标志\n\n遍历 existingChildren Map，将 Map 中所有节点添加到父节点的 deletions 数组中\n\n![UML 图 (5).jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f287eb10bb94c4f94e8c710a7606e7f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n## DOM 变更\n\nDOM 元素类型的 fiber 节点上存有对 DOM 节点的引用，因此在 commit 阶段，深度优先遍历每个新 fiber 节点，对 fiber 节点对应的 DOM 节点做以下变更：\n\n1. 删除 deletions 数组中 fiber 对应的 DOM 节点\n\n1. 如有 Placement 标志，将节点移动到往后第一个没有 Placement 标记的fiber的DOM节点之前\n\n1. 更新节点。以 DOM 节点为例，在生成 fiber 树的「归」阶段，会找出属性的变更集，在 commit 阶段更新属性\n\n![UML 图 (6).jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7044fc48726b49389413bcf801aeeb10~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n## 最坏的情况\n\n在处理节点往前移的情况，React 的 diff 算法表现得就不太好了。以下图为例，节点 a、b、c、d 变为了 d、a、b、c，如果我们手动处理这种位置变化，只需要一步：将 d 节点移动到 a 前面。但 React 实际上的做法有三步：将 a、b、c 三个节点依次插入到 d 节点后面\n\n这是因为遍历完 d 节点后，lastPlacedIndex 变成了 3，再去遍历 a、b、c、d 时，oldIndex 一定小于 lastPlacedIndex 了\n\n![UML 图 (7).jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71569a9e6e8045b585b0b1d5c3f100ea~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n因此，实际编写代码时，应该尽量避免节点往前移动的操作\n\n# Vue2中的双端Diff算法\n\nVue2中的双端Diff是旧的一组VNode( 旧子节点 )和新的一组VNode( 新子节点 )进行对比\n\n## 第一轮遍历\n\n所谓的双端, 表示在新旧子节点的数组中, 各用两个指针指向头尾节点, 在遍历过程中, 头尾指针不断靠拢. 因此, 用newStartIndex和newEndIndex分别指向新子节点中未处理的头尾节点, 用oldStartIndex和oldEndIndex分别指向旧子节点中未处理节点的头尾节点\n\n现在, 我们用「新前」表示新子节点中未处理节点的第一个节点; 用「新后」表示新子节点中未处理的最后一个节点; 「旧前」表示旧子节点中未处理节点的第一个节点; 用「旧后」表示旧子节点中未处理节点的最后一个节点\n\n每遍历到一个节点, 就尝试进行双端比较: 「新前 vs 旧前」、「新后 vs 旧后」、「新后 vs 旧前」、「新前 vs 旧后」, 如果匹配成功, 更新双端的指针 . 比如, 新旧子节点通过「新前 vs 旧后」匹配成功，那么 newStartIndex += 1，oldEndIndex -= 1\n\n如果新旧子节点通过「新后 vs 旧前」匹配成功, 还需要将「旧前」对应的DOM节点插入到「旧后」对应的DOM节点之后. 如果新旧节点通过「新前 vs 旧后」, 还需要将「旧后」对应的DOM节点插入到「旧前」对应的DOM节点之前\n\n如果通过双端比较都没法找到匹配的节点, 就需要一个React中的existingChildren Map的Map对象了, 在Vue2的diff中, 这个名字叫做oldKeyToIdx Map. 通过这个Map, 遍历时可以尝试根据新子节点的key去找oldIndex, 查找结果会有两种:\n\n找到oldIndex, 即新旧子节点有相同key的节点\n\n如果VNode的type是相同的, 将旧子节点对应的DOM节点插入到「旧前」对应的DOM节点之前\n\n如果VNode的type是不同的, 创建一个新的DOM节点, 并插入到「旧前」对应的DOM节点之前\n\n没找到oldIndex, 需要根据新子节点(VNode)创建DOM元素, 并插入到「旧前」对应的DOM节点之前\n\n简单来说, 第一轮遍历会先尝试比较新旧子节点的双端节点, 如果匹配不成功, 再尝试在旧子节点中找到对应的节点. 至于DOM节点的移动, 需要记住只能移动到「旧前」之前或「旧后」之后 . 如果更新后节点位置被调到前面了 移动时就需要移动到「旧前」之前; 如果更新后节点位置被调到后面了, 移动时就需要移到「旧后」之后\n\n## 第二轮遍历\n\n如果第一轮遍历后, 只剩下新子节点( newStartIndex>newEndIndex ) , 则根据剩余的新子节点(VNode)创建DOM节点, 并依次插入到父级DOM节点最后\n\n如果第一轮遍历后, 只剩下旧子节点(oldStartIndex>oldEndIndex), 则将剩余旧子节点对应的DOM节点依次从父级DOM节点中删除\n\n需要注意的是, Vue在diff过程中, 会直接进行节点的更新/新建/删除操作, 这点和React是不同的\n\n下面展示了Vue2双端Diff的一些例子, 能够更好的消化理解算法:\n\n![UML 图 (8).jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c45e7a6ad91b49f0ac9ec35e15484359~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n# React为什么不使用双端diff\n\n简单地总结React不使用双端diff的原因: 由于双端diff需要向前查找节点, 但每个fiber节点上都没有反向指针, 即前一个fiber通过sibling属性指向后一个fiber, 只能从前往后遍历, 而不能反过来\n\n# Vue3中的快速Diff算法\n\n注意: Vue3多节点的diff是旧的一组VNode( 旧子节点 ) 和新的一组VNode( 新子节点 )进行对比\n\n## 第一轮遍历\n\n先从新旧子节点的头部节点开始, 一个一个进行对比, 直到遇到不同的节点, 再从新旧子节点的尾部节点开始, 一个一个进行对比, 直到遇到不相同的节点\n\n![UML 图 (9).jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8985f95f59dd4ef083fc5318a39c7708~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n## 第二轮遍历\n\n如果第一轮遍历结束之后还有新子节点或旧子节点未被处理, 那么会有三种情况:\n\n1. 只剩下新子节点         \n2. 只剩下旧子节点          \n3. 新旧子节点都有剩下的\n\n## 第一种情况: 只剩下新子节点\n\n对于剩余的新子节点, 依次创建对应的DOM节点, 并插到尾部已处理节点之前\n\n![UML 图 (10).jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af7e3ca002e04e13a5899893753a5d63~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n## 第二种情况: 只剩下旧子节点\n\n对于剩余的旧子节点，依次从父级 DOM 节点中删除对应的 DOM 节点\n\n![UML 图 (11).jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac8c2b3d4cdf4422a722c36cc9c288cf~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n----\n\n## 第三种情况: 新旧子节点都有剩下的\n\n这种情况下有可能有节点需要移动, 假设旧子节点的位置索引序列是递增序列, 使用新子节点在旧子节点中的位置索引组合成一个位置索引序列, 如果这个序列是非递增序列, 如果这个序列是非递增序列, 那么就肯定存在节点移动的情况. 进一步思考, 可以发现新的位置索引序列中的最大递增子序列是不需要移动的, 其余索引对应的节点才需要移动\n\n因此, 需要引入求解最长递增子序列的算法\n\n求解最长递增子序列：**贪心 + 二分查找**\n\n---\n\n现在让我们通过一个例子来理解处理流程吧\n\n旧子节点\n\n```html\n<div>\n  <div key=\"a\">a</div>\n  <div key=\"b\">b</div>\n  <div key=\"c\">c</div>\n  <div key=\"d\">d</div>\n  <div key=\"f\">f</div>\n  <div key=\"e\">e</div>\n</div>\n```\n\n新子节点\n\n```html\n<div>\n  <div key=\"a\">a</div>\n  <div key=\"c\">c</div>\n  <div key=\"d\">d</div>\n  <div key=\"b\">b</div>\n  <div key=\"g\">g</div>\n  <div key=\"e\">e</div>\n</div>\n```\n\n要求解最长递增子序列我们就先需要一个数组 newIndexToOldIndexMap（虽然源码中叫 Map，但它实际上是一个数组），这个数组表示新的一组子节点中的节点在旧的一组子节点中的位置索引。这个数组中的 0 值表示对应位置索引的新子节点在旧的一组子节点中不存在匹配的节点，证明需要挂载新的 DOM 节点。因此，只要新子节点在旧的一组子节点中能找到匹配的节点，在记录位置索引到 newIndexToOldIndexMap 前，都需要将位置索引做加 1 处理。\n\n为了构造这个 newIndexToOldIndexMap 数组，需要遍历未处理的旧子节点，遍历过程主要做以下事情：\n\n1. 填充 newIndexToOldIndexMap 数组\n\n1. 确定是否存在需要移动的节点。这个结果将用于判断是否需要求解最长递增子序列，在没有节点移动的情况下，能降低时间复杂度。判断方法本质上和 React 是类似的实现原理，Vue 3 将访问过的最大 newIndex（旧子节点在新的一组子节点中的位置索引）记录到一个叫 maxNewIndexSoFar 的变量中，如果当前 newIndex < maxNewIndexSoFar，证明存在需要移动的节点\n\n1. 更新那些能找到对应新子节点的旧子节点\n\n1. 卸载那些找不到对应新子节点的旧子节点\n\n![1101-1.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8cc0ca3ac56c4bcc89157b0989e79334~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n遍历完旧子节点后，数组 newIndexToOldIndexMap 为：[2, 3, 1, 0]，尽管最长递增子序列是 [2, 3]，但我们需要知道哪些位置的节点是不需要移动的，所以得到这样一个叫 increasingNewIndexSequence 的数组：[0, 1]，表示第一和第二个节点是不需要移动的\n\n接下来从后往前遍历新子节点（假设 i 为当前遍历节点的位置索引）：\n\n如果 newIndexToOldIndexMap[i] 为 0，需要新建 DOM 节点，插入到右边新子节点（VNode）的 DOM 节点之前\n\n如果 increasingNewIndexSequence 数组里不包含 i，证明这个新子节点不在最长递增子序列中，需要将它对应的 DOM 节点需要插入到右边新子节点的 DOM 节点之前\n\n如果 increasingNewIndexSequence 数组里包含 i，证明当前新子节点对应的 DOM 节点不需要移动\n\n注意，遍历新子节点时不再需要更新节点，因为在遍历旧子节点时已经更新过了\n\n![UML 图 (12).jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5712293272e342dd8e179183d2e17f6c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"diff算法","published":1,"date":"2023-02-06T11:56:53.615Z","updated":"2023-02-10T02:21:02.340Z","_id":"cldss27sv000050s602m2049r","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"前置知识：虚拟-DOM\"><a href=\"#前置知识：虚拟-DOM\" class=\"headerlink\" title=\"前置知识：虚拟 DOM\"></a>前置知识：虚拟 DOM</h1><p>虚拟 DOM 节点是一个 JS 对象，用这个 JS 对象可以表示 DOM 节点、组件节点等，创建一个虚拟 DOM 节点比创建一个 DOM 节点的代价要小很多。有了虚拟 DOM，能提高我们的研发体验和效率，同时也能解决跨平台的问题</p>\n<p>在 Vue 中，通常用 VNode 指代一个虚拟 DOM 节点，我们最终会根据 VNode 生成 DOM 节点. 在 React 中，通过 React.createElement 也能生成一个虚拟 DOM 节点（ReactElement）</p>\n<h1 id=\"React中的DOM架构\"><a href=\"#React中的DOM架构\" class=\"headerlink\" title=\"React中的DOM架构\"></a>React中的DOM架构</h1><p>在 React15 及以前，采用了递归的方式创建虚拟 DOM，递归过程是不能中断的。如果组件树的层级很深，递归会占用线程很多时间，造成卡顿。React16 将递归的无法中断的更新重构为异步的可中断更新，推出了新的 Fiber 架构</p>\n<p>原本的 ReactElement 只有 children，在中断恢复时，无法找到其兄弟节点和父节点，无法从断点处继续完成渲染工作。而 fiber 节点上能访问到父节点、子节点、兄弟节点，所以即使渲染被打断了，也可以恢复查找未处理的节点。因此，React 需要先生成 ReactElement，再生成 fiber，最后才将变更映射到真实 DOM 节点。这一点和 Vue 有很大不同</p>\n<p>React 采用了双缓存的技术，在 React 中最多会存在两颗 fiber 树，当前屏幕上显示内容对应的 fiber 树称为 current fiber 树，正在内存中构建的 fiber 树称为 workInProgress fiber 树。当 workInProgress fiber 树构建并渲染到页面上后，应用根节点的 current 指针指向 workInProgress Fiber 树，此时workInProgress Fiber 树就变为 current Fiber 树</p>\n<p>假设我们有这样一段代码：</p>\n<pre><code class=\"react\">const App = () =&gt; &#123;\n  const [count, setCount] = React.useState(0)\n  return &lt;div onClick=&#123;() =&gt; setCount(n =&gt; n + 1)&#125;&gt;&#123;count&#125;&lt;/div&gt;\n&#125;\n\nReactDOM.createRoot(document.getElementById(&#39;root&#39;)).render(&lt;App /&gt;)\n</code></pre>\n<p>那么，对应的 fiber 树会经历如下图所示的变化过程：</p>\n<img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ccc58df27154105b150ee9a7a24ba10~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?\" alt=\"UML 图.jpg \" style=\"zoom:67%;\" />\n\n<p>React 的更新会经历两个阶段：render 阶段 和 commit 阶段。render 阶段是可中断的，commit 阶段是不可中断的</p>\n<p>render 阶段会生成 fiber 树，所谓的 diff 就会发生在这个阶段。React 通过深度优先遍历来生成 fiber 树，整个过程与递归是类似的，因此生成 fiber 树的过程又可以分为「递」阶段和「归」阶段</p>\n<p>commit 阶段主要执行各种 DOM 操作、生命周期钩子、某些 hook 等</p>\n<p>因此，diff 阶段不会直接变更 DOM，而是留到 commit 阶段再做变更</p>\n<p>Vue 与 React 不同，它通过递归的形式生成整个虚拟 DOM 树，在 diff 的同时会对 DOM 做变更</p>\n<h1 id=\"React-18中简单diff算法\"><a href=\"#React-18中简单diff算法\" class=\"headerlink\" title=\"React 18中简单diff算法\"></a>React 18中简单diff算法</h1><p>React 每次更新时，会将新的 ReactElement（即 React.createElement() 的返回值）与旧的 fiber 树作对比，比较出它们的差异后，构建出新的 fiber 树，因此多节点的diff实际上是用 fiber（旧子节点）和 ReactElement 数组（新子节点）进行对比</p>\n<h2 id=\"第一轮遍历\"><a href=\"#第一轮遍历\" class=\"headerlink\" title=\"第一轮遍历\"></a>第一轮遍历</h2><p>React 团队发现，在实际的场景中，更新节点的情况要大于新增和删除节点的情况，因此第一轮遍历会先尝试更新子节点</p>\n<p>遍历逻辑如下：</p>\n<p>如果新旧子节点的 key 和 type（节点类型，如 div、p、span、函数组件名）都相同，则根据旧 fiber 和 新 ReactElement 的 props 生成新子节点 fiber</p>\n<p>如果新旧子节点的 key 相同，但 type 不同，将根据新 ReactElement 生成新 fiber，旧 fiber 将被添加到它的父级 fiber 的 deletions 数组中，后续将被移除</p>\n<p>如果新旧子节点的 key 和 type 都不相同，结束遍历</p>\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72f401ece31e418f86c1e40206eb9117~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?\" alt=\"UML 图 (1).jpg \" style=\"zoom:67%;\" />\n\n<h2 id=\"第二轮遍历\"><a href=\"#第二轮遍历\" class=\"headerlink\" title=\"第二轮遍历\"></a>第二轮遍历</h2><p>如果第一轮遍历被提前终止了，意味着还有新 ReactElement 或 旧 fiber 还未被遍历。因此会有第二轮遍历去处理以下三种情况：</p>\n<p>只剩旧子节点</p>\n<p>只剩新子节点</p>\n<p>新旧子节点都有剩</p>\n<p>下图分别展示了这三种情况：</p>\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84d81f81ddf54fe59a989a48356ff8e3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?\" alt=\"UML 图 (2).jpg \" style=\"zoom:67%;\" />\n\n<h3 id=\"第一种情况-只剩旧子节点\"><a href=\"#第一种情况-只剩旧子节点\" class=\"headerlink\" title=\"第一种情况: 只剩旧子节点\"></a>第一种情况: 只剩旧子节点</h3><p>只剩下旧子节点的处理方法很简单，只需要将剩余的旧 fiber 放到父 fiber 的 deletions 数组中，这些旧 fiber 对应的 DOM 节点将会在 commit 阶段被移除</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ed4b64494db48eb953c216c70feeff7~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"UML 图 (3).jpg\"></p>\n<h3 id=\"第二种情况-只剩新子节点\"><a href=\"#第二种情况-只剩新子节点\" class=\"headerlink\" title=\"第二种情况: 只剩新子节点\"></a>第二种情况: 只剩新子节点</h3><p>对于剩余的新子节点，先创建新的 fiber 节点，然后打上 Placement 标记，我们将在遍历 fiber 树的「归」阶段生成这些新 fiber 对应的 DOM 节点</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d97dac1167024d30bfc5fe8e3ec4d075~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"UML 图 (4).jpg\"></p>\n<h3 id=\"第三种情况-新旧子节点都有剩\"><a href=\"#第三种情况-新旧子节点都有剩\" class=\"headerlink\" title=\"第三种情况: 新旧子节点都有剩\"></a>第三种情况: 新旧子节点都有剩</h3><p>这种情况下，需要一个快速的方法帮助我们快速找到某个 ReactElement 在上一次渲染时生成的 fiber 节点。因此，我们需要一个 existingChildren Map，这个 Map 保存了旧 fiber 的 key 到 旧 fiber 的映射关系，我们可以通过新的 ReactElement 的 key 快速在这个 Map 中找到对应的旧 fiber，如果能找到，则能复用旧 fiber 以生成新 fiber；如果找不到，证明要生成新的 fiber，并打上一个 Placement 标志，以便于在 commit 阶段插入该 fiber 对应的 DOM 节点。</p>\n<p>我们还需要找到哪些节点的位置发生了变化</p>\n<p>假设我们有 a、b、c、d 四个节点，它们的位置索引是 0、1、2、3，是一个递增的序列。在更新后，它们顺序发生了变化，变成了 a、c、b、d，那么它们的位置索引变为 0、2、1、3（继续沿用旧的位置索引），不再是一个递增的序列，因为索引 1 移到了 2 的后面（即 b 原本在 c 前面，更新后被移到了 c 后面），破坏了递增的规律。因此，只需要找到那些破坏了索引递增规律的节点，就知道哪些节点的位置发生了变化。那具体要怎么做呢？</p>\n<p>其实，旧 fiber 上有 index 属性，index 属性记录了在上一次渲染时该 fiber 所在的位置索引。现在，我们暂且叫这个旧 fiber 上的 index 属性为 oldIndex，把遍历新子节点过程中访问过的最大 oldIndex 叫为 lastPlacedIndex，那么，只要当前新子节点有对应的旧 fiber，且 oldIndex &lt; lastPlacedIndex，就可以认为该新子节点对应的 DOM 节点需要往后移动，并打上一个 Placement 标志，以便于在 commit 阶段识别出这个需要移动 DOM 节点的 fiber</p>\n<p>遍历逻辑如下：</p>\n<p>遍历未处理的旧子节点，生成 existingChildren Map</p>\n<p>从前到后遍历新子节点</p>\n<p>如果能在 existingChildren Map 中找到对应的旧 fiber，根据旧 fiber 生成新 fiber；如果不能，生成新 fiber，并打上 Placement 标志</p>\n<p>从 existingChildren Map 中删除已处理的节点</p>\n<p>如果新子节点有对应的旧 fiber</p>\n<p>当 oldIndex &lt; lastPlacedIndex 时，给新 fiber 打上 Placement 标志；否则，令 lastPlacedIndex &#x3D; newIndex</p>\n<p>如果新子节点没有对应的旧 fiber，创建一个新 fiber 并 打上 Placement 标志</p>\n<p>遍历 existingChildren Map，将 Map 中所有节点添加到父节点的 deletions 数组中</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f287eb10bb94c4f94e8c710a7606e7f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"UML 图 (5).jpg\"></p>\n<h2 id=\"DOM-变更\"><a href=\"#DOM-变更\" class=\"headerlink\" title=\"DOM 变更\"></a>DOM 变更</h2><p>DOM 元素类型的 fiber 节点上存有对 DOM 节点的引用，因此在 commit 阶段，深度优先遍历每个新 fiber 节点，对 fiber 节点对应的 DOM 节点做以下变更：</p>\n<ol>\n<li><p>删除 deletions 数组中 fiber 对应的 DOM 节点</p>\n</li>\n<li><p>如有 Placement 标志，将节点移动到往后第一个没有 Placement 标记的fiber的DOM节点之前</p>\n</li>\n<li><p>更新节点。以 DOM 节点为例，在生成 fiber 树的「归」阶段，会找出属性的变更集，在 commit 阶段更新属性</p>\n</li>\n</ol>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7044fc48726b49389413bcf801aeeb10~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"UML 图 (6).jpg\"></p>\n<h2 id=\"最坏的情况\"><a href=\"#最坏的情况\" class=\"headerlink\" title=\"最坏的情况\"></a>最坏的情况</h2><p>在处理节点往前移的情况，React 的 diff 算法表现得就不太好了。以下图为例，节点 a、b、c、d 变为了 d、a、b、c，如果我们手动处理这种位置变化，只需要一步：将 d 节点移动到 a 前面。但 React 实际上的做法有三步：将 a、b、c 三个节点依次插入到 d 节点后面</p>\n<p>这是因为遍历完 d 节点后，lastPlacedIndex 变成了 3，再去遍历 a、b、c、d 时，oldIndex 一定小于 lastPlacedIndex 了</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71569a9e6e8045b585b0b1d5c3f100ea~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"UML 图 (7).jpg\"></p>\n<p>因此，实际编写代码时，应该尽量避免节点往前移动的操作</p>\n<h1 id=\"Vue2中的双端Diff算法\"><a href=\"#Vue2中的双端Diff算法\" class=\"headerlink\" title=\"Vue2中的双端Diff算法\"></a>Vue2中的双端Diff算法</h1><p>Vue2中的双端Diff是旧的一组VNode( 旧子节点 )和新的一组VNode( 新子节点 )进行对比</p>\n<h2 id=\"第一轮遍历-1\"><a href=\"#第一轮遍历-1\" class=\"headerlink\" title=\"第一轮遍历\"></a>第一轮遍历</h2><p>所谓的双端, 表示在新旧子节点的数组中, 各用两个指针指向头尾节点, 在遍历过程中, 头尾指针不断靠拢. 因此, 用newStartIndex和newEndIndex分别指向新子节点中未处理的头尾节点, 用oldStartIndex和oldEndIndex分别指向旧子节点中未处理节点的头尾节点</p>\n<p>现在, 我们用「新前」表示新子节点中未处理节点的第一个节点; 用「新后」表示新子节点中未处理的最后一个节点; 「旧前」表示旧子节点中未处理节点的第一个节点; 用「旧后」表示旧子节点中未处理节点的最后一个节点</p>\n<p>每遍历到一个节点, 就尝试进行双端比较: 「新前 vs 旧前」、「新后 vs 旧后」、「新后 vs 旧前」、「新前 vs 旧后」, 如果匹配成功, 更新双端的指针 . 比如, 新旧子节点通过「新前 vs 旧后」匹配成功，那么 newStartIndex +&#x3D; 1，oldEndIndex -&#x3D; 1</p>\n<p>如果新旧子节点通过「新后 vs 旧前」匹配成功, 还需要将「旧前」对应的DOM节点插入到「旧后」对应的DOM节点之后. 如果新旧节点通过「新前 vs 旧后」, 还需要将「旧后」对应的DOM节点插入到「旧前」对应的DOM节点之前</p>\n<p>如果通过双端比较都没法找到匹配的节点, 就需要一个React中的existingChildren Map的Map对象了, 在Vue2的diff中, 这个名字叫做oldKeyToIdx Map. 通过这个Map, 遍历时可以尝试根据新子节点的key去找oldIndex, 查找结果会有两种:</p>\n<p>找到oldIndex, 即新旧子节点有相同key的节点</p>\n<p>如果VNode的type是相同的, 将旧子节点对应的DOM节点插入到「旧前」对应的DOM节点之前</p>\n<p>如果VNode的type是不同的, 创建一个新的DOM节点, 并插入到「旧前」对应的DOM节点之前</p>\n<p>没找到oldIndex, 需要根据新子节点(VNode)创建DOM元素, 并插入到「旧前」对应的DOM节点之前</p>\n<p>简单来说, 第一轮遍历会先尝试比较新旧子节点的双端节点, 如果匹配不成功, 再尝试在旧子节点中找到对应的节点. 至于DOM节点的移动, 需要记住只能移动到「旧前」之前或「旧后」之后 . 如果更新后节点位置被调到前面了 移动时就需要移动到「旧前」之前; 如果更新后节点位置被调到后面了, 移动时就需要移到「旧后」之后</p>\n<h2 id=\"第二轮遍历-1\"><a href=\"#第二轮遍历-1\" class=\"headerlink\" title=\"第二轮遍历\"></a>第二轮遍历</h2><p>如果第一轮遍历后, 只剩下新子节点( newStartIndex&gt;newEndIndex ) , 则根据剩余的新子节点(VNode)创建DOM节点, 并依次插入到父级DOM节点最后</p>\n<p>如果第一轮遍历后, 只剩下旧子节点(oldStartIndex&gt;oldEndIndex), 则将剩余旧子节点对应的DOM节点依次从父级DOM节点中删除</p>\n<p>需要注意的是, Vue在diff过程中, 会直接进行节点的更新&#x2F;新建&#x2F;删除操作, 这点和React是不同的</p>\n<p>下面展示了Vue2双端Diff的一些例子, 能够更好的消化理解算法:</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c45e7a6ad91b49f0ac9ec35e15484359~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"UML 图 (8).jpg\"></p>\n<h1 id=\"React为什么不使用双端diff\"><a href=\"#React为什么不使用双端diff\" class=\"headerlink\" title=\"React为什么不使用双端diff\"></a>React为什么不使用双端diff</h1><p>简单地总结React不使用双端diff的原因: 由于双端diff需要向前查找节点, 但每个fiber节点上都没有反向指针, 即前一个fiber通过sibling属性指向后一个fiber, 只能从前往后遍历, 而不能反过来</p>\n<h1 id=\"Vue3中的快速Diff算法\"><a href=\"#Vue3中的快速Diff算法\" class=\"headerlink\" title=\"Vue3中的快速Diff算法\"></a>Vue3中的快速Diff算法</h1><p>注意: Vue3多节点的diff是旧的一组VNode( 旧子节点 ) 和新的一组VNode( 新子节点 )进行对比</p>\n<h2 id=\"第一轮遍历-2\"><a href=\"#第一轮遍历-2\" class=\"headerlink\" title=\"第一轮遍历\"></a>第一轮遍历</h2><p>先从新旧子节点的头部节点开始, 一个一个进行对比, 直到遇到不同的节点, 再从新旧子节点的尾部节点开始, 一个一个进行对比, 直到遇到不相同的节点</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8985f95f59dd4ef083fc5318a39c7708~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"UML 图 (9).jpg\"></p>\n<h2 id=\"第二轮遍历-2\"><a href=\"#第二轮遍历-2\" class=\"headerlink\" title=\"第二轮遍历\"></a>第二轮遍历</h2><p>如果第一轮遍历结束之后还有新子节点或旧子节点未被处理, 那么会有三种情况:</p>\n<ol>\n<li>只剩下新子节点         </li>\n<li>只剩下旧子节点          </li>\n<li>新旧子节点都有剩下的</li>\n</ol>\n<h2 id=\"第一种情况-只剩下新子节点\"><a href=\"#第一种情况-只剩下新子节点\" class=\"headerlink\" title=\"第一种情况: 只剩下新子节点\"></a>第一种情况: 只剩下新子节点</h2><p>对于剩余的新子节点, 依次创建对应的DOM节点, 并插到尾部已处理节点之前</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af7e3ca002e04e13a5899893753a5d63~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"UML 图 (10).jpg\"></p>\n<h2 id=\"第二种情况-只剩下旧子节点\"><a href=\"#第二种情况-只剩下旧子节点\" class=\"headerlink\" title=\"第二种情况: 只剩下旧子节点\"></a>第二种情况: 只剩下旧子节点</h2><p>对于剩余的旧子节点，依次从父级 DOM 节点中删除对应的 DOM 节点</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac8c2b3d4cdf4422a722c36cc9c288cf~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"UML 图 (11).jpg\"></p>\n<hr>\n<h2 id=\"第三种情况-新旧子节点都有剩下的\"><a href=\"#第三种情况-新旧子节点都有剩下的\" class=\"headerlink\" title=\"第三种情况: 新旧子节点都有剩下的\"></a>第三种情况: 新旧子节点都有剩下的</h2><p>这种情况下有可能有节点需要移动, 假设旧子节点的位置索引序列是递增序列, 使用新子节点在旧子节点中的位置索引组合成一个位置索引序列, 如果这个序列是非递增序列, 如果这个序列是非递增序列, 那么就肯定存在节点移动的情况. 进一步思考, 可以发现新的位置索引序列中的最大递增子序列是不需要移动的, 其余索引对应的节点才需要移动</p>\n<p>因此, 需要引入求解最长递增子序列的算法</p>\n<p>求解最长递增子序列：<strong>贪心 + 二分查找</strong></p>\n<hr>\n<p>现在让我们通过一个例子来理解处理流程吧</p>\n<p>旧子节点</p>\n<pre><code class=\"html\">&lt;div&gt;\n  &lt;div key=&quot;a&quot;&gt;a&lt;/div&gt;\n  &lt;div key=&quot;b&quot;&gt;b&lt;/div&gt;\n  &lt;div key=&quot;c&quot;&gt;c&lt;/div&gt;\n  &lt;div key=&quot;d&quot;&gt;d&lt;/div&gt;\n  &lt;div key=&quot;f&quot;&gt;f&lt;/div&gt;\n  &lt;div key=&quot;e&quot;&gt;e&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<p>新子节点</p>\n<pre><code class=\"html\">&lt;div&gt;\n  &lt;div key=&quot;a&quot;&gt;a&lt;/div&gt;\n  &lt;div key=&quot;c&quot;&gt;c&lt;/div&gt;\n  &lt;div key=&quot;d&quot;&gt;d&lt;/div&gt;\n  &lt;div key=&quot;b&quot;&gt;b&lt;/div&gt;\n  &lt;div key=&quot;g&quot;&gt;g&lt;/div&gt;\n  &lt;div key=&quot;e&quot;&gt;e&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<p>要求解最长递增子序列我们就先需要一个数组 newIndexToOldIndexMap（虽然源码中叫 Map，但它实际上是一个数组），这个数组表示新的一组子节点中的节点在旧的一组子节点中的位置索引。这个数组中的 0 值表示对应位置索引的新子节点在旧的一组子节点中不存在匹配的节点，证明需要挂载新的 DOM 节点。因此，只要新子节点在旧的一组子节点中能找到匹配的节点，在记录位置索引到 newIndexToOldIndexMap 前，都需要将位置索引做加 1 处理。</p>\n<p>为了构造这个 newIndexToOldIndexMap 数组，需要遍历未处理的旧子节点，遍历过程主要做以下事情：</p>\n<ol>\n<li><p>填充 newIndexToOldIndexMap 数组</p>\n</li>\n<li><p>确定是否存在需要移动的节点。这个结果将用于判断是否需要求解最长递增子序列，在没有节点移动的情况下，能降低时间复杂度。判断方法本质上和 React 是类似的实现原理，Vue 3 将访问过的最大 newIndex（旧子节点在新的一组子节点中的位置索引）记录到一个叫 maxNewIndexSoFar 的变量中，如果当前 newIndex &lt; maxNewIndexSoFar，证明存在需要移动的节点</p>\n</li>\n<li><p>更新那些能找到对应新子节点的旧子节点</p>\n</li>\n<li><p>卸载那些找不到对应新子节点的旧子节点</p>\n</li>\n</ol>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8cc0ca3ac56c4bcc89157b0989e79334~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"1101-1.jpg\"></p>\n<p>遍历完旧子节点后，数组 newIndexToOldIndexMap 为：[2, 3, 1, 0]，尽管最长递增子序列是 [2, 3]，但我们需要知道哪些位置的节点是不需要移动的，所以得到这样一个叫 increasingNewIndexSequence 的数组：[0, 1]，表示第一和第二个节点是不需要移动的</p>\n<p>接下来从后往前遍历新子节点（假设 i 为当前遍历节点的位置索引）：</p>\n<p>如果 newIndexToOldIndexMap[i] 为 0，需要新建 DOM 节点，插入到右边新子节点（VNode）的 DOM 节点之前</p>\n<p>如果 increasingNewIndexSequence 数组里不包含 i，证明这个新子节点不在最长递增子序列中，需要将它对应的 DOM 节点需要插入到右边新子节点的 DOM 节点之前</p>\n<p>如果 increasingNewIndexSequence 数组里包含 i，证明当前新子节点对应的 DOM 节点不需要移动</p>\n<p>注意，遍历新子节点时不再需要更新节点，因为在遍历旧子节点时已经更新过了</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5712293272e342dd8e179183d2e17f6c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"UML 图 (12).jpg\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前置知识：虚拟-DOM\"><a href=\"#前置知识：虚拟-DOM\" class=\"headerlink\" title=\"前置知识：虚拟 DOM\"></a>前置知识：虚拟 DOM</h1><p>虚拟 DOM 节点是一个 JS 对象，用这个 JS 对象可以表示 DOM 节点、组件节点等，创建一个虚拟 DOM 节点比创建一个 DOM 节点的代价要小很多。有了虚拟 DOM，能提高我们的研发体验和效率，同时也能解决跨平台的问题</p>\n<p>在 Vue 中，通常用 VNode 指代一个虚拟 DOM 节点，我们最终会根据 VNode 生成 DOM 节点. 在 React 中，通过 React.createElement 也能生成一个虚拟 DOM 节点（ReactElement）</p>\n<h1 id=\"React中的DOM架构\"><a href=\"#React中的DOM架构\" class=\"headerlink\" title=\"React中的DOM架构\"></a>React中的DOM架构</h1><p>在 React15 及以前，采用了递归的方式创建虚拟 DOM，递归过程是不能中断的。如果组件树的层级很深，递归会占用线程很多时间，造成卡顿。React16 将递归的无法中断的更新重构为异步的可中断更新，推出了新的 Fiber 架构</p>\n<p>原本的 ReactElement 只有 children，在中断恢复时，无法找到其兄弟节点和父节点，无法从断点处继续完成渲染工作。而 fiber 节点上能访问到父节点、子节点、兄弟节点，所以即使渲染被打断了，也可以恢复查找未处理的节点。因此，React 需要先生成 ReactElement，再生成 fiber，最后才将变更映射到真实 DOM 节点。这一点和 Vue 有很大不同</p>\n<p>React 采用了双缓存的技术，在 React 中最多会存在两颗 fiber 树，当前屏幕上显示内容对应的 fiber 树称为 current fiber 树，正在内存中构建的 fiber 树称为 workInProgress fiber 树。当 workInProgress fiber 树构建并渲染到页面上后，应用根节点的 current 指针指向 workInProgress Fiber 树，此时workInProgress Fiber 树就变为 current Fiber 树</p>\n<p>假设我们有这样一段代码：</p>\n<pre><code class=\"react\">const App = () =&gt; &#123;\n  const [count, setCount] = React.useState(0)\n  return &lt;div onClick=&#123;() =&gt; setCount(n =&gt; n + 1)&#125;&gt;&#123;count&#125;&lt;/div&gt;\n&#125;\n\nReactDOM.createRoot(document.getElementById(&#39;root&#39;)).render(&lt;App /&gt;)\n</code></pre>\n<p>那么，对应的 fiber 树会经历如下图所示的变化过程：</p>\n<img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ccc58df27154105b150ee9a7a24ba10~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?\" alt=\"UML 图.jpg \" style=\"zoom:67%;\" />\n\n<p>React 的更新会经历两个阶段：render 阶段 和 commit 阶段。render 阶段是可中断的，commit 阶段是不可中断的</p>\n<p>render 阶段会生成 fiber 树，所谓的 diff 就会发生在这个阶段。React 通过深度优先遍历来生成 fiber 树，整个过程与递归是类似的，因此生成 fiber 树的过程又可以分为「递」阶段和「归」阶段</p>\n<p>commit 阶段主要执行各种 DOM 操作、生命周期钩子、某些 hook 等</p>\n<p>因此，diff 阶段不会直接变更 DOM，而是留到 commit 阶段再做变更</p>\n<p>Vue 与 React 不同，它通过递归的形式生成整个虚拟 DOM 树，在 diff 的同时会对 DOM 做变更</p>\n<h1 id=\"React-18中简单diff算法\"><a href=\"#React-18中简单diff算法\" class=\"headerlink\" title=\"React 18中简单diff算法\"></a>React 18中简单diff算法</h1><p>React 每次更新时，会将新的 ReactElement（即 React.createElement() 的返回值）与旧的 fiber 树作对比，比较出它们的差异后，构建出新的 fiber 树，因此多节点的diff实际上是用 fiber（旧子节点）和 ReactElement 数组（新子节点）进行对比</p>\n<h2 id=\"第一轮遍历\"><a href=\"#第一轮遍历\" class=\"headerlink\" title=\"第一轮遍历\"></a>第一轮遍历</h2><p>React 团队发现，在实际的场景中，更新节点的情况要大于新增和删除节点的情况，因此第一轮遍历会先尝试更新子节点</p>\n<p>遍历逻辑如下：</p>\n<p>如果新旧子节点的 key 和 type（节点类型，如 div、p、span、函数组件名）都相同，则根据旧 fiber 和 新 ReactElement 的 props 生成新子节点 fiber</p>\n<p>如果新旧子节点的 key 相同，但 type 不同，将根据新 ReactElement 生成新 fiber，旧 fiber 将被添加到它的父级 fiber 的 deletions 数组中，后续将被移除</p>\n<p>如果新旧子节点的 key 和 type 都不相同，结束遍历</p>\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72f401ece31e418f86c1e40206eb9117~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?\" alt=\"UML 图 (1).jpg \" style=\"zoom:67%;\" />\n\n<h2 id=\"第二轮遍历\"><a href=\"#第二轮遍历\" class=\"headerlink\" title=\"第二轮遍历\"></a>第二轮遍历</h2><p>如果第一轮遍历被提前终止了，意味着还有新 ReactElement 或 旧 fiber 还未被遍历。因此会有第二轮遍历去处理以下三种情况：</p>\n<p>只剩旧子节点</p>\n<p>只剩新子节点</p>\n<p>新旧子节点都有剩</p>\n<p>下图分别展示了这三种情况：</p>\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84d81f81ddf54fe59a989a48356ff8e3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?\" alt=\"UML 图 (2).jpg \" style=\"zoom:67%;\" />\n\n<h3 id=\"第一种情况-只剩旧子节点\"><a href=\"#第一种情况-只剩旧子节点\" class=\"headerlink\" title=\"第一种情况: 只剩旧子节点\"></a>第一种情况: 只剩旧子节点</h3><p>只剩下旧子节点的处理方法很简单，只需要将剩余的旧 fiber 放到父 fiber 的 deletions 数组中，这些旧 fiber 对应的 DOM 节点将会在 commit 阶段被移除</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ed4b64494db48eb953c216c70feeff7~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"UML 图 (3).jpg\"></p>\n<h3 id=\"第二种情况-只剩新子节点\"><a href=\"#第二种情况-只剩新子节点\" class=\"headerlink\" title=\"第二种情况: 只剩新子节点\"></a>第二种情况: 只剩新子节点</h3><p>对于剩余的新子节点，先创建新的 fiber 节点，然后打上 Placement 标记，我们将在遍历 fiber 树的「归」阶段生成这些新 fiber 对应的 DOM 节点</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d97dac1167024d30bfc5fe8e3ec4d075~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"UML 图 (4).jpg\"></p>\n<h3 id=\"第三种情况-新旧子节点都有剩\"><a href=\"#第三种情况-新旧子节点都有剩\" class=\"headerlink\" title=\"第三种情况: 新旧子节点都有剩\"></a>第三种情况: 新旧子节点都有剩</h3><p>这种情况下，需要一个快速的方法帮助我们快速找到某个 ReactElement 在上一次渲染时生成的 fiber 节点。因此，我们需要一个 existingChildren Map，这个 Map 保存了旧 fiber 的 key 到 旧 fiber 的映射关系，我们可以通过新的 ReactElement 的 key 快速在这个 Map 中找到对应的旧 fiber，如果能找到，则能复用旧 fiber 以生成新 fiber；如果找不到，证明要生成新的 fiber，并打上一个 Placement 标志，以便于在 commit 阶段插入该 fiber 对应的 DOM 节点。</p>\n<p>我们还需要找到哪些节点的位置发生了变化</p>\n<p>假设我们有 a、b、c、d 四个节点，它们的位置索引是 0、1、2、3，是一个递增的序列。在更新后，它们顺序发生了变化，变成了 a、c、b、d，那么它们的位置索引变为 0、2、1、3（继续沿用旧的位置索引），不再是一个递增的序列，因为索引 1 移到了 2 的后面（即 b 原本在 c 前面，更新后被移到了 c 后面），破坏了递增的规律。因此，只需要找到那些破坏了索引递增规律的节点，就知道哪些节点的位置发生了变化。那具体要怎么做呢？</p>\n<p>其实，旧 fiber 上有 index 属性，index 属性记录了在上一次渲染时该 fiber 所在的位置索引。现在，我们暂且叫这个旧 fiber 上的 index 属性为 oldIndex，把遍历新子节点过程中访问过的最大 oldIndex 叫为 lastPlacedIndex，那么，只要当前新子节点有对应的旧 fiber，且 oldIndex &lt; lastPlacedIndex，就可以认为该新子节点对应的 DOM 节点需要往后移动，并打上一个 Placement 标志，以便于在 commit 阶段识别出这个需要移动 DOM 节点的 fiber</p>\n<p>遍历逻辑如下：</p>\n<p>遍历未处理的旧子节点，生成 existingChildren Map</p>\n<p>从前到后遍历新子节点</p>\n<p>如果能在 existingChildren Map 中找到对应的旧 fiber，根据旧 fiber 生成新 fiber；如果不能，生成新 fiber，并打上 Placement 标志</p>\n<p>从 existingChildren Map 中删除已处理的节点</p>\n<p>如果新子节点有对应的旧 fiber</p>\n<p>当 oldIndex &lt; lastPlacedIndex 时，给新 fiber 打上 Placement 标志；否则，令 lastPlacedIndex &#x3D; newIndex</p>\n<p>如果新子节点没有对应的旧 fiber，创建一个新 fiber 并 打上 Placement 标志</p>\n<p>遍历 existingChildren Map，将 Map 中所有节点添加到父节点的 deletions 数组中</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f287eb10bb94c4f94e8c710a7606e7f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"UML 图 (5).jpg\"></p>\n<h2 id=\"DOM-变更\"><a href=\"#DOM-变更\" class=\"headerlink\" title=\"DOM 变更\"></a>DOM 变更</h2><p>DOM 元素类型的 fiber 节点上存有对 DOM 节点的引用，因此在 commit 阶段，深度优先遍历每个新 fiber 节点，对 fiber 节点对应的 DOM 节点做以下变更：</p>\n<ol>\n<li><p>删除 deletions 数组中 fiber 对应的 DOM 节点</p>\n</li>\n<li><p>如有 Placement 标志，将节点移动到往后第一个没有 Placement 标记的fiber的DOM节点之前</p>\n</li>\n<li><p>更新节点。以 DOM 节点为例，在生成 fiber 树的「归」阶段，会找出属性的变更集，在 commit 阶段更新属性</p>\n</li>\n</ol>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7044fc48726b49389413bcf801aeeb10~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"UML 图 (6).jpg\"></p>\n<h2 id=\"最坏的情况\"><a href=\"#最坏的情况\" class=\"headerlink\" title=\"最坏的情况\"></a>最坏的情况</h2><p>在处理节点往前移的情况，React 的 diff 算法表现得就不太好了。以下图为例，节点 a、b、c、d 变为了 d、a、b、c，如果我们手动处理这种位置变化，只需要一步：将 d 节点移动到 a 前面。但 React 实际上的做法有三步：将 a、b、c 三个节点依次插入到 d 节点后面</p>\n<p>这是因为遍历完 d 节点后，lastPlacedIndex 变成了 3，再去遍历 a、b、c、d 时，oldIndex 一定小于 lastPlacedIndex 了</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71569a9e6e8045b585b0b1d5c3f100ea~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"UML 图 (7).jpg\"></p>\n<p>因此，实际编写代码时，应该尽量避免节点往前移动的操作</p>\n<h1 id=\"Vue2中的双端Diff算法\"><a href=\"#Vue2中的双端Diff算法\" class=\"headerlink\" title=\"Vue2中的双端Diff算法\"></a>Vue2中的双端Diff算法</h1><p>Vue2中的双端Diff是旧的一组VNode( 旧子节点 )和新的一组VNode( 新子节点 )进行对比</p>\n<h2 id=\"第一轮遍历-1\"><a href=\"#第一轮遍历-1\" class=\"headerlink\" title=\"第一轮遍历\"></a>第一轮遍历</h2><p>所谓的双端, 表示在新旧子节点的数组中, 各用两个指针指向头尾节点, 在遍历过程中, 头尾指针不断靠拢. 因此, 用newStartIndex和newEndIndex分别指向新子节点中未处理的头尾节点, 用oldStartIndex和oldEndIndex分别指向旧子节点中未处理节点的头尾节点</p>\n<p>现在, 我们用「新前」表示新子节点中未处理节点的第一个节点; 用「新后」表示新子节点中未处理的最后一个节点; 「旧前」表示旧子节点中未处理节点的第一个节点; 用「旧后」表示旧子节点中未处理节点的最后一个节点</p>\n<p>每遍历到一个节点, 就尝试进行双端比较: 「新前 vs 旧前」、「新后 vs 旧后」、「新后 vs 旧前」、「新前 vs 旧后」, 如果匹配成功, 更新双端的指针 . 比如, 新旧子节点通过「新前 vs 旧后」匹配成功，那么 newStartIndex +&#x3D; 1，oldEndIndex -&#x3D; 1</p>\n<p>如果新旧子节点通过「新后 vs 旧前」匹配成功, 还需要将「旧前」对应的DOM节点插入到「旧后」对应的DOM节点之后. 如果新旧节点通过「新前 vs 旧后」, 还需要将「旧后」对应的DOM节点插入到「旧前」对应的DOM节点之前</p>\n<p>如果通过双端比较都没法找到匹配的节点, 就需要一个React中的existingChildren Map的Map对象了, 在Vue2的diff中, 这个名字叫做oldKeyToIdx Map. 通过这个Map, 遍历时可以尝试根据新子节点的key去找oldIndex, 查找结果会有两种:</p>\n<p>找到oldIndex, 即新旧子节点有相同key的节点</p>\n<p>如果VNode的type是相同的, 将旧子节点对应的DOM节点插入到「旧前」对应的DOM节点之前</p>\n<p>如果VNode的type是不同的, 创建一个新的DOM节点, 并插入到「旧前」对应的DOM节点之前</p>\n<p>没找到oldIndex, 需要根据新子节点(VNode)创建DOM元素, 并插入到「旧前」对应的DOM节点之前</p>\n<p>简单来说, 第一轮遍历会先尝试比较新旧子节点的双端节点, 如果匹配不成功, 再尝试在旧子节点中找到对应的节点. 至于DOM节点的移动, 需要记住只能移动到「旧前」之前或「旧后」之后 . 如果更新后节点位置被调到前面了 移动时就需要移动到「旧前」之前; 如果更新后节点位置被调到后面了, 移动时就需要移到「旧后」之后</p>\n<h2 id=\"第二轮遍历-1\"><a href=\"#第二轮遍历-1\" class=\"headerlink\" title=\"第二轮遍历\"></a>第二轮遍历</h2><p>如果第一轮遍历后, 只剩下新子节点( newStartIndex&gt;newEndIndex ) , 则根据剩余的新子节点(VNode)创建DOM节点, 并依次插入到父级DOM节点最后</p>\n<p>如果第一轮遍历后, 只剩下旧子节点(oldStartIndex&gt;oldEndIndex), 则将剩余旧子节点对应的DOM节点依次从父级DOM节点中删除</p>\n<p>需要注意的是, Vue在diff过程中, 会直接进行节点的更新&#x2F;新建&#x2F;删除操作, 这点和React是不同的</p>\n<p>下面展示了Vue2双端Diff的一些例子, 能够更好的消化理解算法:</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c45e7a6ad91b49f0ac9ec35e15484359~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"UML 图 (8).jpg\"></p>\n<h1 id=\"React为什么不使用双端diff\"><a href=\"#React为什么不使用双端diff\" class=\"headerlink\" title=\"React为什么不使用双端diff\"></a>React为什么不使用双端diff</h1><p>简单地总结React不使用双端diff的原因: 由于双端diff需要向前查找节点, 但每个fiber节点上都没有反向指针, 即前一个fiber通过sibling属性指向后一个fiber, 只能从前往后遍历, 而不能反过来</p>\n<h1 id=\"Vue3中的快速Diff算法\"><a href=\"#Vue3中的快速Diff算法\" class=\"headerlink\" title=\"Vue3中的快速Diff算法\"></a>Vue3中的快速Diff算法</h1><p>注意: Vue3多节点的diff是旧的一组VNode( 旧子节点 ) 和新的一组VNode( 新子节点 )进行对比</p>\n<h2 id=\"第一轮遍历-2\"><a href=\"#第一轮遍历-2\" class=\"headerlink\" title=\"第一轮遍历\"></a>第一轮遍历</h2><p>先从新旧子节点的头部节点开始, 一个一个进行对比, 直到遇到不同的节点, 再从新旧子节点的尾部节点开始, 一个一个进行对比, 直到遇到不相同的节点</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8985f95f59dd4ef083fc5318a39c7708~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"UML 图 (9).jpg\"></p>\n<h2 id=\"第二轮遍历-2\"><a href=\"#第二轮遍历-2\" class=\"headerlink\" title=\"第二轮遍历\"></a>第二轮遍历</h2><p>如果第一轮遍历结束之后还有新子节点或旧子节点未被处理, 那么会有三种情况:</p>\n<ol>\n<li>只剩下新子节点         </li>\n<li>只剩下旧子节点          </li>\n<li>新旧子节点都有剩下的</li>\n</ol>\n<h2 id=\"第一种情况-只剩下新子节点\"><a href=\"#第一种情况-只剩下新子节点\" class=\"headerlink\" title=\"第一种情况: 只剩下新子节点\"></a>第一种情况: 只剩下新子节点</h2><p>对于剩余的新子节点, 依次创建对应的DOM节点, 并插到尾部已处理节点之前</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af7e3ca002e04e13a5899893753a5d63~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"UML 图 (10).jpg\"></p>\n<h2 id=\"第二种情况-只剩下旧子节点\"><a href=\"#第二种情况-只剩下旧子节点\" class=\"headerlink\" title=\"第二种情况: 只剩下旧子节点\"></a>第二种情况: 只剩下旧子节点</h2><p>对于剩余的旧子节点，依次从父级 DOM 节点中删除对应的 DOM 节点</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac8c2b3d4cdf4422a722c36cc9c288cf~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"UML 图 (11).jpg\"></p>\n<hr>\n<h2 id=\"第三种情况-新旧子节点都有剩下的\"><a href=\"#第三种情况-新旧子节点都有剩下的\" class=\"headerlink\" title=\"第三种情况: 新旧子节点都有剩下的\"></a>第三种情况: 新旧子节点都有剩下的</h2><p>这种情况下有可能有节点需要移动, 假设旧子节点的位置索引序列是递增序列, 使用新子节点在旧子节点中的位置索引组合成一个位置索引序列, 如果这个序列是非递增序列, 如果这个序列是非递增序列, 那么就肯定存在节点移动的情况. 进一步思考, 可以发现新的位置索引序列中的最大递增子序列是不需要移动的, 其余索引对应的节点才需要移动</p>\n<p>因此, 需要引入求解最长递增子序列的算法</p>\n<p>求解最长递增子序列：<strong>贪心 + 二分查找</strong></p>\n<hr>\n<p>现在让我们通过一个例子来理解处理流程吧</p>\n<p>旧子节点</p>\n<pre><code class=\"html\">&lt;div&gt;\n  &lt;div key=&quot;a&quot;&gt;a&lt;/div&gt;\n  &lt;div key=&quot;b&quot;&gt;b&lt;/div&gt;\n  &lt;div key=&quot;c&quot;&gt;c&lt;/div&gt;\n  &lt;div key=&quot;d&quot;&gt;d&lt;/div&gt;\n  &lt;div key=&quot;f&quot;&gt;f&lt;/div&gt;\n  &lt;div key=&quot;e&quot;&gt;e&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<p>新子节点</p>\n<pre><code class=\"html\">&lt;div&gt;\n  &lt;div key=&quot;a&quot;&gt;a&lt;/div&gt;\n  &lt;div key=&quot;c&quot;&gt;c&lt;/div&gt;\n  &lt;div key=&quot;d&quot;&gt;d&lt;/div&gt;\n  &lt;div key=&quot;b&quot;&gt;b&lt;/div&gt;\n  &lt;div key=&quot;g&quot;&gt;g&lt;/div&gt;\n  &lt;div key=&quot;e&quot;&gt;e&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<p>要求解最长递增子序列我们就先需要一个数组 newIndexToOldIndexMap（虽然源码中叫 Map，但它实际上是一个数组），这个数组表示新的一组子节点中的节点在旧的一组子节点中的位置索引。这个数组中的 0 值表示对应位置索引的新子节点在旧的一组子节点中不存在匹配的节点，证明需要挂载新的 DOM 节点。因此，只要新子节点在旧的一组子节点中能找到匹配的节点，在记录位置索引到 newIndexToOldIndexMap 前，都需要将位置索引做加 1 处理。</p>\n<p>为了构造这个 newIndexToOldIndexMap 数组，需要遍历未处理的旧子节点，遍历过程主要做以下事情：</p>\n<ol>\n<li><p>填充 newIndexToOldIndexMap 数组</p>\n</li>\n<li><p>确定是否存在需要移动的节点。这个结果将用于判断是否需要求解最长递增子序列，在没有节点移动的情况下，能降低时间复杂度。判断方法本质上和 React 是类似的实现原理，Vue 3 将访问过的最大 newIndex（旧子节点在新的一组子节点中的位置索引）记录到一个叫 maxNewIndexSoFar 的变量中，如果当前 newIndex &lt; maxNewIndexSoFar，证明存在需要移动的节点</p>\n</li>\n<li><p>更新那些能找到对应新子节点的旧子节点</p>\n</li>\n<li><p>卸载那些找不到对应新子节点的旧子节点</p>\n</li>\n</ol>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8cc0ca3ac56c4bcc89157b0989e79334~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"1101-1.jpg\"></p>\n<p>遍历完旧子节点后，数组 newIndexToOldIndexMap 为：[2, 3, 1, 0]，尽管最长递增子序列是 [2, 3]，但我们需要知道哪些位置的节点是不需要移动的，所以得到这样一个叫 increasingNewIndexSequence 的数组：[0, 1]，表示第一和第二个节点是不需要移动的</p>\n<p>接下来从后往前遍历新子节点（假设 i 为当前遍历节点的位置索引）：</p>\n<p>如果 newIndexToOldIndexMap[i] 为 0，需要新建 DOM 节点，插入到右边新子节点（VNode）的 DOM 节点之前</p>\n<p>如果 increasingNewIndexSequence 数组里不包含 i，证明这个新子节点不在最长递增子序列中，需要将它对应的 DOM 节点需要插入到右边新子节点的 DOM 节点之前</p>\n<p>如果 increasingNewIndexSequence 数组里包含 i，证明当前新子节点对应的 DOM 节点不需要移动</p>\n<p>注意，遍历新子节点时不再需要更新节点，因为在遍历旧子节点时已经更新过了</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5712293272e342dd8e179183d2e17f6c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"UML 图 (12).jpg\"></p>\n"},{"title":"React源码解析1:jsxDev函数","_content":"","source":"_posts/jsxDev.md","raw":"---\ntitle:  \"React源码解析1:jsxDev函数\"\ncategory: React源码\n---","slug":"jsxDev","published":1,"date":"2023-02-10T02:19:32.619Z","updated":"2023-02-10T02:20:43.842Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldxwmwlh0000fls60wjuhxr9","content":"","site":{"data":{}},"excerpt":"","more":""}],"PostAsset":[],"PostCategory":[{"post_id":"cldqt8vn40000jps6cgvt9fle","category_id":"clds8g0hr0000xws62t297bma","_id":"clds8g0ht0001xws6gz3sdjci"},{"post_id":"cldss27sv000050s602m2049r","category_id":"cldxvtmer0000sos6ecszbeaa","_id":"cldxvtmeu0001sos6d4plhrsp"},{"post_id":"cldxwmwlh0000fls60wjuhxr9","category_id":"cldxwm58v000173s6fc7u1e3h","_id":"cldxwmwll0001fls6725w3twn"}],"PostTag":[],"Tag":[]}}